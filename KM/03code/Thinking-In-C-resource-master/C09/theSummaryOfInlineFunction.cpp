/*
 *内联函数总结：
 *在c语言中，保持效率的一个方法就是使用宏(marco)．
 *宏可以不要普通函数的调用代价就可以使之看起来像函数调用．
 *宏的实现是通过预处理器而不是编译器．预处理器直接用宏代码
 *代替宏调用，所以就没有了参数压栈，生成汇编语言的CALL，返回
 *参数，执行汇编语言的RETURN等的开销．所有的工作由处理器在
 *预处理阶段完成，因此不用用产生什么花费就具有了程序调用的便利
 *和可读性．
 *然而正是因为预处理器是直接进行替换的，所以会导致一些问题．
 *举例说明，这是一个我们经常看到的求最大值的常用宏:
 *#define	MAX(a,b)	(((a) > (b)) ? (a) : (b))
 *一般情况下我们调用的时候是不会出现问题的，然而当我们像下面
 *这种情况进行使用的时候，就会出现问题了
 *MAX(a++, b);
 *因为预处理器会直接进行展开所以会变成下面这种情况:
 *(((a++) > (b)) ? (a++) : (b));
 *这个结果肯定不是你想要的．
 *还有一个我自己工程中遇到的问题，也是这样的．
 *我需要一个字符串，这个字符串最后一个字母会随着循环次数的增加
 *而从a开始自增．
 *开始我是这样进行处理的．
 *#define ADDSTRING(x)	"theStringNeedAutoIncrementing"###(x)
 *for(char i = 'a'; i < 'z'; i++) {
 *        printf("%s\n", ADDSTRING(i));
 *}
 *程序打印结果，字符串最后的一个字母是i而不是a，因为宏被替换后
 *字符串会变成:
 *"theStringNeedAutoIncrementingi";
 *这就是当我们把一个宏当成一个函数来处理的时候，会出现问题的地方．
 *
 *宏对于面向对象这种有访问控制的语言来说，不能实现这种要求，宏没有
 *成员函数作用域．
 *因此，为了避免宏的这些问题．而又不失效率, 在c++中使用内联函数来
 *实现对宏的替代．
 *
 *内联函数能够像普通函数一样具有我们我们所期望的任何行为．唯一不同
 *之处是内联函数在适当的地方像宏一样展开．所以不需要函数调用的开销．
 *
 *任何在类里定义的函数自动地成为内联函数．非类的函数可以在函数前面
 *加上inline关键字使之成为内联函数，但需要注意的是，必须是函数体和
 *声明结合在一起．否则，编译器把它当作普通函数对待．
 *一般应该把内联定义放在头文件里．
 *
 *内联函数使用最多的地方就是用作访问函数，它用用来访问和改变成员变量．
 *
 *不能内联的情况：
 *一般的，任何种类的循环都被认为太复杂而不扩展为内联函数．
 *假如要显示的取函数地址，编译器也不能执行内联．
 *向前引用：
 *只有在类声明结束后，其中的内联函数才会被计算．
 *因为构造函数和析构函数里面往往会隐藏很多行为，所以建议不内联．
 *可以在前期建立程序的初始轮廓的时候使用内联函数，但是后期考虑效率的
 *时候，内联是一个值得注意的问题．
 */
