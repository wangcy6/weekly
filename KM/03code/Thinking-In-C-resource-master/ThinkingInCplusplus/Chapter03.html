<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIC2Vone.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/01/2000
Translation Time:14:48:24
Translation Platform:Win32
Number of Output files:22
This File:Chapter03.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>3: The C in C++</TITLE>
</HEAD>

<BODY  BGCOLOR="#FFFFFF"><DIV ALIGN="CENTER">
  <a href="http://www.MindView.net">
  <img src="mindview-head.gif" alt="MindView Inc." BORDER = "0"></a>
  <CENTER>
    <FONT FACE="Verdana" size = "-1">
    [ <a href="README-HTML.txt">Viewing Hints</a> ]
    [ <a href="http://www.mindview.net/CPPServices/SolutionGuide.html">Exercise Solutions</a> ]
    [ <a href="http://www.mindview.net/ThinkingInCPP2e.html">Volume 2</a> ]
    [ <a href="http://www.mindview.net/MailingList.html">Free Newsletter</a> ] <br>
    [ <a href="http://www.mindview.net/CPPServices/#PublicSeminars">Seminars</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#SeminarsOnCD">Seminars on CD ROM</a> ]
    [ <a href="http://www.mindview.net/CPPServices/#ConsultingServices">Consulting</a> ]
    </FONT>
  <H2><FONT FACE="Verdana">
  Thinking in C++, 2nd ed. Volume 1</FONT></H2></FONT>
  <H3><FONT FACE="Verdana">&copy;2000 by Bruce Eckel</FONT></H3></FONT>
  
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter02.html">Previous Chapter</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter04.html">Next Chapter</a> ] 
    </FONT>
    
  </CENTER>
  </P></DIV><A NAME="_Toc472654741"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
3: The C in C++</H1></FONT>
<A NAME="Heading99"></A><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana" SIZE=4>Since C++ is based on C, you must
be familiar with the syntax of C in order to program in C++, just as you
</FONT><BR><FONT FACE="Verdana" SIZE=4>must be reasonably fluent in algebra in
order to tackle calculus.</FONT><BR></P></DIV>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;ve never seen
<A NAME="Index418"></A><A NAME="Index419"></A>C before, this chapter will give
you a decent background in the style of C used in C++. If you are familiar with
the style of C described in the first edition of Kernighan &amp; Ritchie (often
called K&amp;R C<A NAME="Index420"></A>), you will find some new and different
features in C++ as well as in Standard C. If you are familiar with Standard C,
you should skim through this chapter looking for features that are particular to
C++. Note that there are some fundamental C++ features introduced here, which
are basic ideas that are akin to the features in C or often modifications to the
way that C does things. The more sophisticated C++ features will not be
introduced until later chapters.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter is a fairly fast coverage of
C constructs and introduction to some basic C++ constructs, with the
understanding that you&#8217;ve had some experience programming in another
language. <A NAME="Index421"></A>A more gentle introduction to C is found in the
<A NAME="Index422"></A>CD ROM packaged in the back of this book, titled
<I>Thinking in C: Foundations for Java &amp; C++</I> by Chuck Allison (published
by MindView, Inc., and also available at www.MindView.net). This is a seminar on
a CD ROM with the goal of taking you carefully through the fundamentals of the C
language. It focuses on the knowledge necessary for you to be able to move on to
the C++ or Java languages rather than trying to make you an expert in all the
dark corners of C (one of the reasons for using a higher-level language like C++
or Java is precisely so we can avoid many of these dark corners). It also
contains exercises and guided solutions. Keep in mind that because this chapter
goes beyond the <I>Thinking in C </I>CD, the CD is not a replacement for this
chapter, but should be used instead as a preparation for this chapter and for
the
book.</FONT><A NAME="_Toc462979737"></A><A NAME="_Toc472654742"></A><BR></P></DIV>
<A NAME="Heading100"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Creating functions<A NAME="Index423"></A><A NAME="Index424"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In old (pre-Standard) C, you could call a
function with any number or type of arguments and the compiler wouldn&#8217;t
complain. Everything seemed fine until you ran the program. You got mysterious
results (or worse, the program crashed) with no hints as to why. The lack of
help with argument passing and the enigmatic bugs that resulted is probably one
reason why C was dubbed a &#8220;high-level assembly
language<A NAME="Index425"></A>.&#8221; Pre-Standard C programmers just adapted
to it.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Standard C and C++ use a feature called
<A NAME="Index426"></A><A NAME="Index427"></A><I>function prototyping</I>.<I>
</I>With function prototyping, you must use a description of the types of
arguments when declaring and defining a function. This description is the
&#8220;prototype.&#8221; When the function is called, the compiler uses the
prototype to ensure that the proper arguments are passed in and that the return
value is treated correctly. If the programmer makes a mistake when calling the
function, the compiler catches the mistake.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Essentially, you learned about function
prototyping (without naming it as such) in the previous chapter, since the form
of function declaration in C++ requires proper prototyping. In a function
prototype, the argument list contains the types of arguments that must be passed
to the function and (optionally for the declaration) identifiers for the
arguments. The order and type of the arguments must match in the declaration,
definition, and function call. Here&#8217;s an example of a function prototype
in a declaration:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> translate(<font color=#0000ff>float</font> x, <font color=#0000ff>float</font> y, <font color=#0000ff>float</font> z);</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You do not use the same form when
declaring variables in function prototypes as you do in ordinary variable
definitions. That is, you cannot say: <B>float x, y, z</B>. You must indicate
the type of <I>each</I> argument. In a function declaration, the following form
is also acceptable:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> translate(<font color=#0000ff>float</font>, <font color=#0000ff>float</font>, <font color=#0000ff>float</font>);</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since the compiler doesn&#8217;t do
anything but check for types when the function is called, the identifiers are
only included for clarity when someone is reading the code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the function definition, names are
required because the arguments are referenced inside the
function:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> translate(<font color=#0000ff>float</font> x, <font color=#0000ff>float</font> y, <font color=#0000ff>float</font> z) {
  x = y = z;
  <font color=#009900>// ...</font>
} </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It turns out this rule applies only to C.
In C++, an argument may be unnamed
<A NAME="Index428"></A><A NAME="Index429"></A>in the argument list of the
function definition. Since it is unnamed, you cannot use it in the function
body, of course. Unnamed arguments are allowed to give the programmer a way to
&#8220;reserve space in the argument list.&#8221; Whoever uses the function must
still call the function with the proper arguments. However, the person creating
the function can then use the argument in the future without forcing
modification of code that calls the function. This option of ignoring an
argument in the list is also possible if you leave the name in, but you will get
an annoying warning message about the value being unused every time you compile
the function. The warning is eliminated if you remove the name.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C and C++ have two other ways to declare
an argument list. If you have an
<A NAME="Index430"></A><A NAME="Index431"></A><A NAME="Index432"></A><A NAME="Index433"></A>empty
argument list, you can declare it as <B>func(&#160;)</B> in C++, which tells the
compiler there are exactly zero arguments. You should be aware that this only
means an empty argument list in C++. In C it means &#8220;an indeterminate
number of arguments (which is a &#8220;hole&#8221; in C since it disables type
checking in that case). In both C and C++, the declaration <B>func(void);</B>
means an empty argument list. The
<A NAME="Index434"></A><A NAME="Index435"></A><B>void</B> keyword means
&#8220;nothing&#8221; in this case (it can also mean &#8220;no type&#8221; in
the case of pointers, as you&#8217;ll see later in this
chapter).<A NAME="Index436"></A><A NAME="Index437"></A><A NAME="Index438"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The other option for argument lists
occurs when you don&#8217;t know how many arguments or what type of arguments
you will have; this is called a <I>variable argument
list<A NAME="Index439"></A><A NAME="Index440"></A><A NAME="Index441"></A></I>.
This &#8220;uncertain argument list&#8221; is represented by ellipses
(<B>...</B>)<A NAME="Index442"></A>. Defining a function with a variable
argument list is significantly more complicated than defining a regular
function. You can use a variable argument list for a function that has a fixed
set of arguments if (for some reason) you want to disable the error checks of
function prototyping. Because of this, you should restrict your use of variable
argument lists to C and avoid them in C++ (in which, as you&#8217;ll learn,
there are much better alternatives). Handling variable argument lists is
described in the library section of your local C
guide.</FONT><A NAME="_Toc462979738"></A><A NAME="_Toc472654743"></A><BR></P></DIV>
<A NAME="Heading101"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Function return values<A NAME="Index443"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A C++ function prototype must specify the
return value type of the function (in C, if you leave off the return value type
it defaults to <B>int</B>). The return type specification precedes the function
name. To specify that no value is returned, use the
<B>void<A NAME="Index444"></A><A NAME="Index445"></A> </B>keyword. This will
generate an error if you try to return a value from the function. Here are some
complete function prototypes:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> f1(<font color=#0000ff>void</font>); <font color=#009900>// Returns an int, takes no arguments</font>
<font color=#0000ff>int</font> f2(); <font color=#009900>// Like f1() in C++ but not in Standard C!</font>
<font color=#0000ff>float</font> f3(<font color=#0000ff>float</font>, <font color=#0000ff>int</font>, <font color=#0000ff>char</font>, <font color=#0000ff>double</font>); <font color=#009900>// Returns a float</font>
<font color=#0000ff>void</font> f4(<font color=#0000ff>void</font>); <font color=#009900>// Takes no arguments, returns nothing</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To return a value from a function, you
use the
<A NAME="Index446"></A><A NAME="Index447"></A><A NAME="Index448"></A><B>return</B>
statement. <B>return</B> exits the function back to the point right after the
function call. If <B>return</B> has an argument, that argument becomes the
return value of the function. If a function says that it will return a
particular type, then each <B>return </B>statement must return that type. You
can have more than one <B>return</B> statement in a function
definition:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Return.cpp</font>
<font color=#009900>// Use of "return"</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>char</font> cfunc(<font color=#0000ff>int</font> i) {
  <font color=#0000ff>if</font>(i == 0)
    <font color=#0000ff>return</font> 'a';
  <font color=#0000ff>if</font>(i == 1)
    <font color=#0000ff>return</font> 'g';
  <font color=#0000ff>if</font>(i == 5)
    <font color=#0000ff>return</font> 'z';
  <font color=#0000ff>return</font> 'c';
}

<font color=#0000ff>int</font> main() {
  cout &lt;&lt; <font color=#004488>"type an integer: "</font>;
  <font color=#0000ff>int</font> val;
  cin &gt;&gt; val;
  cout &lt;&lt; cfunc(val) &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>cfunc(&#160;)</B>, the first
<B>if</B> that evaluates to <B>true</B> exits the function via the <B>return</B>
statement. Notice that a function declaration is not necessary because the
function definition appears before it is used in <B>main(&#160;)</B>, so the
compiler knows about it from that function
definition.</FONT><A NAME="_Toc462979739"></A><A NAME="_Toc472654744"></A><BR></P></DIV>
<A NAME="Heading102"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using the C function library<A NAME="Index449"></A><A NAME="Index450"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All the functions in your local C
function library are available while you are programming in C++. You should look
hard at the function library before defining your own function &#8211;
there&#8217;s a good chance that someone has already solved your problem for
you, and probably given it a lot more thought and debugging.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A word of caution, though: many compilers
include a lot of extra functions that make life even easier and are tempting to
use, but are not part of the Standard C library. If you are certain you will
never want to move the application to another platform (and who is certain of
that?), go ahead &#8211;use those functions and make your life easier. If you
want your application to be portable, you should restrict yourself to Standard
library functions. If you must perform platform-specific activities, try to
isolate that code in one spot so it can be changed easily when porting to
another platform. In C++, platform-specific activities are often encapsulated in
a class, which is the ideal solution.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The formula for using a library function
is as follows: first, find the function in your programming reference (many
programming references will index the function by category as well as
alphabetically). The description of the function should include a section that
demonstrates the syntax of the code. The top of this section usually has at
least one <B>#include</B> line, showing you the header file containing the
function prototype. Duplicate this <B>#include</B> line in your file so the
function is properly
declared<A NAME="Index451"></A><A NAME="Index452"></A><A NAME="Index453"></A>.
Now you can call the function in the same way it appears in the syntax section.
If you make a mistake, the compiler will discover it by comparing your function
call to the function prototype in the header and tell you about your error. The
linker searches the Standard library by default, so that&#8217;s all you need to
do: include the header file and call the
function.</FONT><A NAME="_Toc462979740"></A><A NAME="_Toc472654745"></A><BR></P></DIV>
<A NAME="Heading103"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Creating your own libraries with the librarian <A NAME="Index454"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can collect your own functions
together into a library. Most programming packages come with a librarian that
manages groups of object modules. Each librarian has its own commands, but the
general idea is this: if you want to create a library, make a header file
containing the function prototypes for all the functions in your library. Put
this header file somewhere in the preprocessor&#8217;s search path, either in
the local directory (so it can be found by <B>#include "header"</B>) or in the
include directory (so it can be found by <B>#include &lt;header&gt;</B>). Now
take all the object modules and hand them to the librarian along with a name for
the finished library (most librarians require a common extension, such as
<B>.lib</B> or <B>.a</B>). Place the finished library where the other libraries
reside so the linker can find it. When you use your library, you will have to
add something to the command line so the linker <A NAME="Index455"></A>knows to
search the library for the functions you call. You must find all the details in
your local manual, since they vary from system to
system.</FONT><A NAME="_Toc462979741"></A><A NAME="_Toc472654746"></A><BR></P></DIV>
<A NAME="Heading104"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Controlling execution <A NAME="Index456"></A><A NAME="Index457"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This section covers the execution control
statements in C++. You must be familiar with these statements before you can
read and write C or C++ code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C++ uses all of C&#8217;s execution
control statements. These include <B>if-else</B>, <B>while</B>, <B>do-while</B>,
<B>for</B>, and a selection statement called <B>switch</B>. C++ also allows the
infamous <B>goto</B>, which will be avoided in this
book.</FONT><A NAME="_Toc462979742"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index458"></A><A NAME="Index459"></A><A NAME="_Toc472654747"></A><BR></P></DIV>
<A NAME="Heading105"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
True and false<BR><A NAME="Index460"></A><A NAME="Index461"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All conditional statements use the truth
or falsehood of a conditional expression to determine the execution path. An
example of a conditional expression is <B>A == B</B>. This uses the conditional
operator <B>==</B> to see if the variable <B>A</B> is equivalent to the variable
<B>B.</B> The expression produces a <A NAME="Index462"></A>Boolean <B>true
</B>or <B>false</B> (these are keywords only in C++; in C an expression is
&#8220;true&#8221; if it evaluates to a nonzero value). Other conditional
operators are <B>&gt;</B>, <B>&lt;</B>, <B>&gt;=</B>, etc. Conditional
statements are covered more fully later in this chapter.
</FONT><A NAME="_Toc462979743"></A><A NAME="_Toc472654748"></A><BR></P></DIV>
<A NAME="Heading106"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
if-else<A NAME="Index463"></A><A NAME="Index464"></A><BR><A NAME="Index465"></A><A NAME="Index466"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>if-else</B> statement can exist in
two forms: with or without the <B>else</B>. The two forms are:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(expression)
    statement</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">or</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>if</font>(expression)
    statement
<font color=#0000ff>else</font>
    statement</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The &#8220;expression&#8221; evaluates to
<B>true</B> or <B>false</B>. The &#8220;statement&#8221; means either a simple
statement terminated by a semicolon or a compound statement, which is a group of
simple statements enclosed in braces. Any time the word &#8220;statement&#8221;
is used, it always implies that the statement is simple or compound. Note that
this statement can also be another <B>if</B>, so they can be strung
together.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Ifthen.cpp</font>
<font color=#009900>// Demonstration of if and if-else conditionals</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i;
  cout &lt;&lt; <font color=#004488>"type a number and 'Enter'"</font> &lt;&lt; endl;
  cin &gt;&gt; i;
  <font color=#0000ff>if</font>(i &gt; 5)
    cout &lt;&lt; <font color=#004488>"It's greater than 5"</font> &lt;&lt; endl;
  <font color=#0000ff>else</font>
    <font color=#0000ff>if</font>(i &lt; 5)
      cout &lt;&lt; <font color=#004488>"It's less than 5 "</font> &lt;&lt; endl;
    <font color=#0000ff>else</font>
      cout &lt;&lt; <font color=#004488>"It's equal to 5 "</font> &lt;&lt; endl;

  cout &lt;&lt; <font color=#004488>"type a number and 'Enter'"</font> &lt;&lt; endl;
  cin &gt;&gt; i;
  <font color=#0000ff>if</font>(i &lt; 10)
    <font color=#0000ff>if</font>(i &gt; 5)  <font color=#009900>// "if" is just another statement</font>
      cout &lt;&lt; <font color=#004488>"5 &lt; i &lt; 10"</font> &lt;&lt; endl;
    <font color=#0000ff>else</font>
      cout &lt;&lt; <font color=#004488>"i &lt;= 5"</font> &lt;&lt; endl;
  <font color=#0000ff>else</font> <font color=#009900>// Matches "if(i &lt; 10)"</font>
    cout &lt;&lt; <font color=#004488>"i &gt;= 10"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is conventional to indent the body of
a control flow statement so the reader may easily determine where it begins and
ends</FONT><A NAME="fnB30" HREF="#fn30">[30]</A><FONT FACE="Georgia">.</FONT><A NAME="_Toc462979744"></A><A NAME="_Toc472654749"></A><BR></P></DIV>
<A NAME="Heading107"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
while<A NAME="Index467"></A><A NAME="Index468"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>while</B>, <B>do-while,</B> and
<B>for</B> control looping. A statement repeats until the controlling expression
evaluates to <B>false</B>. The form of a <B>while</B> loop is</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>while</font>(expression)
    statement</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The expression is evaluated once at the
beginning of the loop and again before each further iteration of the
statement.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example stays in the body of the
<B>while</B> loop until you type the secret number or press
control-C.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Guess.cpp</font>
<font color=#009900>// Guess a number (demonstrates "while")</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> secret = 15;
  <font color=#0000ff>int</font> guess = 0;
  <font color=#009900>// "!=" is the "not-equal" conditional:</font>
  <font color=#0000ff>while</font>(guess != secret) { <font color=#009900>// Compound statement</font>
    cout &lt;&lt; <font color=#004488>"guess the number: "</font>;
    cin &gt;&gt; guess;
  }
  cout &lt;&lt; <font color=#004488>"You guessed it!"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>while</B>&#8217;s<B>
</B>conditional expression is not restricted to a simple test as in the example
above; it can be as complicated as you like as long as it produces a <B>true</B>
or <B>false</B> result. You will even see code where the loop has no body, just
a bare semicolon:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>while</font>(<font color=#009900>/* Do a lot here */</font>)
 ;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In these cases, the programmer has
written the conditional expression not only to perform the test but also to do
the
work.</FONT><A NAME="_Toc462979745"></A><A NAME="_Toc472654750"></A><BR></P></DIV>
<A NAME="Heading108"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
do-while<A NAME="Index469"></A><A NAME="Index470"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The form of <B>do-while</B>
is</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>do</font>
    statement
<B><font color=#0000ff>while</font>(</B>expression<B>);</B> </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>do-while</B> is different from the
while because the statement always executes at least once, even if the
expression evaluates to false the first time. In a regular <B>while</B>, if the
conditional is false the first time the statement never
executes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If a <B>do-while</B> is used in
<B>Guess.cpp</B>, the variable <B>guess</B> does not need an initial dummy
value, since it is initialized by the <B>cin</B> statement before it is
tested:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Guess2.cpp</font>
<font color=#009900>// The guess program using do-while</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> secret = 15;
  <font color=#0000ff>int</font> guess; <font color=#009900>// No initialization needed here</font>
  <font color=#0000ff>do</font> {
    cout &lt;&lt; <font color=#004488>"guess the number: "</font>;
    cin &gt;&gt; guess; <font color=#009900>// Initialization happens</font>
  }   <font color=#0000ff>while</font>(guess != secret);
  cout &lt;&lt; <font color=#004488>"You got it!"</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For some reason, most programmers tend to
avoid <B>do-while</B> and just work with
<B>while</B>.</FONT><A NAME="_Toc462979746"></A><A NAME="_Toc472654751"></A><BR></P></DIV>
<A NAME="Heading109"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
for<A NAME="Index471"></A><A NAME="Index472"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>for</B> loop performs initialization
before the first iteration. Then it performs conditional testing and, at the end
of each iteration, some form of &#8220;stepping.&#8221; The form of the
<B>for</B> loop is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>for</font>(initialization; conditional; step)
<B> statement</B></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Any of the expressions
<A NAME="Index473"></A><I>initialization</I>,
<A NAME="Index474"></A><I>conditional,</I> or <A NAME="Index475"></A><I>step</I>
may be empty. The <I>initialization</I> code executes once at the very
beginning. The <I>conditional</I> is tested before each iteration (if it
evaluates to false at the beginning, the statement never executes). At the end
of each loop, the <I>step</I> executes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>for</B> loops are usually used for
&#8220;counting&#8221; tasks:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Charlist.cpp</font>
<font color=#009900>// Display all the ASCII characters</font>
<font color=#009900>// Demonstrates "for"</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 128; i = i + 1)
    <font color=#0000ff>if</font> (i != 26)  <font color=#009900>// ANSI Terminal Clear screen</font>
      cout &lt;&lt; <font color=#004488>" value: "</font> &lt;&lt; i 
           &lt;&lt; <font color=#004488>" character: "</font> 
           &lt;&lt; <font color=#0000ff>char</font>(i) <font color=#009900>// Type conversion</font>
           &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may notice that the variable <B>i</B>
is defined at the point where it is used, instead of at the beginning of the
block denoted by the open curly brace &#8216;<B>{</B>&#8217;. This is in
contrast to traditional procedural languages (including C), which require that
all variables be defined at the beginning of the block. This will be discussed
later in this
chapter.</FONT><A NAME="_Toc462979747"></A><A NAME="_Toc472654752"></A><BR></P></DIV>
<A NAME="Heading110"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The break<A NAME="Index476"></A> and continue <A NAME="Index477"></A>keywords
</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Inside the body of any of the looping
constructs <B>while</B>, <B>do-while,</B> or <B>for</B>,<B> </B>you can control
the flow of the loop using <A NAME="Index478"></A><B>break</B> and
<A NAME="Index479"></A><B>continue</B>. <B>break</B> quits the loop without
executing the rest of the statements in the loop. <B>continue</B> stops the
execution of the current iteration and goes back to the beginning of the loop to
begin a new iteration.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an example of <B>break</B> and
<B>continue</B>, this program is a very simple menu system:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Menu.cpp</font>
<font color=#009900>// Simple menu program demonstrating</font>
<font color=#009900>// the use of "break" and "continue"</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>char</font> c; <font color=#009900>// To hold response</font>
  <font color=#0000ff>while</font>(<font color=#0000ff>true</font>) {
    cout &lt;&lt; <font color=#004488>"MAIN MENU:"</font> &lt;&lt; endl;
    cout &lt;&lt; <font color=#004488>"l: left, r: right, q: quit -&gt; "</font>;
    cin &gt;&gt; c;
    <font color=#0000ff>if</font>(c == 'q')
      <font color=#0000ff>break</font>; <font color=#009900>// Out of "while(1)"</font>
    <font color=#0000ff>if</font>(c == 'l') {
      cout &lt;&lt; <font color=#004488>"LEFT MENU:"</font> &lt;&lt; endl;
      cout &lt;&lt; <font color=#004488>"select a or b: "</font>;
      cin &gt;&gt; c;
      <font color=#0000ff>if</font>(c == 'a') {
        cout &lt;&lt; <font color=#004488>"you chose 'a'"</font> &lt;&lt; endl;
        <font color=#0000ff>continue</font>; <font color=#009900>// Back to main menu</font>
      }
      <font color=#0000ff>if</font>(c == 'b') {
        cout &lt;&lt; <font color=#004488>"you chose 'b'"</font> &lt;&lt; endl;
        <font color=#0000ff>continue</font>; <font color=#009900>// Back to main menu</font>
      }
      <font color=#0000ff>else</font> {
        cout &lt;&lt; <font color=#004488>"you didn't choose a or b!"</font>
             &lt;&lt; endl;
        <font color=#0000ff>continue</font>; <font color=#009900>// Back to main menu</font>
      }
    }
    <font color=#0000ff>if</font>(c == 'r') {
      cout &lt;&lt; <font color=#004488>"RIGHT MENU:"</font> &lt;&lt; endl;
      cout &lt;&lt; <font color=#004488>"select c or d: "</font>;
      cin &gt;&gt; c;
      <font color=#0000ff>if</font>(c == 'c') {
        cout &lt;&lt; <font color=#004488>"you chose 'c'"</font> &lt;&lt; endl;
        <font color=#0000ff>continue</font>; <font color=#009900>// Back to main menu</font>
      }
      <font color=#0000ff>if</font>(c == 'd') {
        cout &lt;&lt; <font color=#004488>"you chose 'd'"</font> &lt;&lt; endl;
        <font color=#0000ff>continue</font>; <font color=#009900>// Back to main menu</font>
      }
      <font color=#0000ff>else</font> {
        cout &lt;&lt; <font color=#004488>"you didn't choose c or d!"</font> 
             &lt;&lt; endl;
        <font color=#0000ff>continue</font>; <font color=#009900>// Back to main menu</font>
      }
    }
    cout &lt;&lt; <font color=#004488>"you must type l or r or q!"</font> &lt;&lt; endl;
  }
  cout &lt;&lt; <font color=#004488>"quitting menu..."</font> &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If the user selects &#8216;q&#8217; in
the main menu, the <B>break</B> keyword is used to quit, otherwise the program
just continues to execute indefinitely. After each of the sub-menu selections,
the <B>continue</B> keyword is used to pop back up to the beginning of the while
loop.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>while(true)</B> statement is the
equivalent of saying &#8220;do this loop forever.&#8221; The <B>break</B>
statement allows you to break out of this infinite while loop when the user
types a &#8216;q.&#8217;
</FONT><A NAME="_Toc462979748"></A><A NAME="_Toc472654753"></A><BR></P></DIV>
<A NAME="Heading111"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
switch<A NAME="Index480"></A><A NAME="Index481"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>switch</B> statement selects from
among pieces of code based on the value of an integral expression. Its form
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>switch</font>(selector) {
    <font color=#0000ff>case</font> integral-value1 : statement; <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> integral-value2 : statement; <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> integral-value3 : statement; <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> integral-value4 : statement; <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> integral-value5 : statement; <font color=#0000ff>break</font>;
    (...)
    <font color=#0000ff>default</font>: statement;
<B>}</B> </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><I>Selector</I> is an expression that
produces an integral value. The <B>switch</B> compares the result of
<I>selector</I> to each <I>integral value</I>. If it finds a match, the
corresponding statement (simple or compound) executes. If no match occurs, the
<B>default</B> <A NAME="Index482"></A><A NAME="Index483"></A>statement
executes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You will notice in the definition above
that each <B>case<A NAME="Index484"></A><A NAME="Index485"></A></B> ends with a
<B>break</B>, which causes execution to jump to the end of the <B>switch</B>
body (the closing brace that completes the <B>switch</B>). This is the
conventional way to build a <B>switch</B> statement, but the <B>break</B> is
optional. If it is missing, your <B>case </B>&#8220;drops through&#8221; to the
one after it. That is, the code for the following <B>case</B> statements execute
until a <B>break</B> is encountered. Although you don&#8217;t usually want this
kind of behavior, it can be useful to an experienced
programmer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>switch</B> statement is a clean
way to implement <A NAME="Index486"></A><A NAME="Index487"></A>multi-way
selection (i.e., selecting from among a number of different execution paths),
but it requires a selector that evaluates to an integral value at compile-time.
If you want to use, for example, a <B>string</B> object as a selector, it
won&#8217;t work in a <B>switch</B> statement. For a <B>string</B> selector, you
must instead use a series of <B>if</B> statements and compare the <B>string</B>
inside the conditional.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The menu example shown above provides a
particularly nice example of a <B>switch</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Menu2.cpp</font>
<font color=#009900>// A menu using a switch statement</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>bool</font> quit = <font color=#0000ff>false</font>;  <font color=#009900>// Flag for quitting</font>
  <font color=#0000ff>while</font>(quit == <font color=#0000ff>false</font>) {
    cout &lt;&lt; <font color=#004488>"Select a, b, c or q to quit: "</font>;
    <font color=#0000ff>char</font> response;
    cin &gt;&gt; response;
    <font color=#0000ff>switch</font>(response) {
      <font color=#0000ff>case</font> 'a' : cout &lt;&lt; <font color=#004488>"you chose 'a'"</font> &lt;&lt; endl;
                 <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> 'b' : cout &lt;&lt; <font color=#004488>"you chose 'b'"</font> &lt;&lt; endl;
                 <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> 'c' : cout &lt;&lt; <font color=#004488>"you chose 'c'"</font> &lt;&lt; endl;
                 <font color=#0000ff>break</font>;
      <font color=#0000ff>case</font> 'q' : cout &lt;&lt; <font color=#004488>"quitting menu"</font> &lt;&lt; endl;
                 quit = <font color=#0000ff>true</font>;
                 <font color=#0000ff>break</font>;
      <font color=#0000ff>default</font>  : cout &lt;&lt; <font color=#004488>"Please use a,b,c or q!"</font>
                 &lt;&lt; endl;
    }
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>quit </B>flag is a
<A NAME="Index488"></A><A NAME="Index489"></A><B>bool</B>, short for
&#8220;Boolean,&#8221; which is a type you&#8217;ll find only in C++. It can
have only the keyword values <B>true</B> or <B>false</B>.<B> </B>Selecting
&#8216;q&#8217; sets the <B>quit</B> flag to <B>true</B>. The next time the
selector is evaluated, <B>quit == false</B> returns <B>false</B> so the body of
the <B>while</B> does not
execute.</FONT><A NAME="_Toc462979749"></A><A NAME="_Toc472654754"></A><BR></P></DIV>
<A NAME="Heading112"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using and misusing goto</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index490"></A><A NAME="Index491"></A><B>goto</B> keyword is supported
in C++, since it exists in C. Using <B>goto</B> is often dismissed as poor
programming style, and most of the time it is. Anytime you use <B>goto</B>, look
at your code and see if there&#8217;s another way to do it. On rare occasions,
you may discover <B>goto</B> can solve a problem that can&#8217;t be solved
otherwise, but still, consider it carefully. Here&#8217;s an example that might
make a plausible candidate:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:gotoKeyword.cpp</font>
<font color=#009900>// The infamous goto is supported in C++</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>long</font> val = 0;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt; 1000; i++) {
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> j = 1; j &lt; 100; j += 10) {
      val = i * j;
      <font color=#0000ff>if</font>(val &gt; 47000)
        <font color=#0000ff>goto</font> bottom; 
        <font color=#009900>// Break would only go to the outer 'for'</font>
    }
  }
  bottom: <font color=#009900>// A label</font>
  cout &lt;&lt; val &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The alternative would be to set a Boolean
that is tested in the outer <B>for</B> loop, and then do a <B>break</B> from the
inner for loop. However, if you have several levels of <B>for</B> or
<B>while</B> this could get awkward.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index492"></A><A NAME="_Toc472654755"></A><BR></P></DIV>
<A NAME="Heading113"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Recursion</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Recursion is an interesting and sometimes
useful programming technique whereby you call the function that you&#8217;re in.
Of course, if this is all you do, you&#8217;ll keep calling the function
you&#8217;re in until you run out of memory, so there must be some way to
&#8220;bottom out&#8221; the recursive call. In the following example, this
&#8220;bottoming out&#8221; is accomplished by simply saying that the recursion
will go only until the <B>cat</B> exceeds
&#8216;Z&#8217;:</FONT><A NAME="fnB31" HREF="#fn31">[31]</A><A NAME="Index493"></A><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:CatsInHats.cpp</font>
<font color=#009900>// Simple demonstration of recursion</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> removeHat(<font color=#0000ff>char</font> cat) {
  <font color=#0000ff>for</font>(<font color=#0000ff>char</font> c = 'A'; c &lt; cat; c++)
    cout &lt;&lt; <font color=#004488>"  "</font>;
  <font color=#0000ff>if</font>(cat &lt;= 'Z') {
    cout &lt;&lt; <font color=#004488>"cat "</font> &lt;&lt; cat &lt;&lt; endl;
    removeHat(cat + 1); <font color=#009900>// Recursive call</font>
  } <font color=#0000ff>else</font>
    cout &lt;&lt; <font color=#004488>"VOOM!!!"</font> &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  removeHat('A');
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>removeHat(&#160;)</B>, you can see
that as long as <B>cat</B> is less than &#8216;Z&#8217;,
<B>removeHat(&#160;)</B> will be called from <I>within</I>
<B>removeHat(&#160;)</B>, thus effecting the recursion. Each time
<B>removeHat(&#160;)</B> is called, its argument is one greater than the current
<B>cat</B> so the argument keeps increasing.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Recursion is often used when evaluating
some sort of arbitrarily complex problem, since you aren&#8217;t restricted to a
particular &#8220;size&#8221; for the solution &#8211; the function can just
keep recursing until it&#8217;s reached the end of the problem.</FONT><BR></P></DIV>
<A NAME="Heading114"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
<A NAME="_Toc462979750"></A><A NAME="_Toc472654756"></A>Introduction to
operators<A NAME="Index494"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can think of operators as a special
type of function (you&#8217;ll learn that C++ operator overloading treats
operators precisely that way). An operator takes one or more arguments and
produces a new value. The arguments are in a different form than ordinary
function calls, but the effect is the same.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">From your previous programming
experience, you should be reasonably comfortable with the operators that have
been used so far. The concepts of addition (<B>+</B>), subtraction and unary
minus (<B>-</B>), multiplication (<B>*</B>), division (<B>/</B>), and
assignment(<B>=</B>) all have essentially the same meaning in any programming
language. The full set of operators is enumerated later in this
chapter.</FONT><A NAME="_Toc462979751"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index495"></A><A NAME="_Toc472654757"></A><BR></P></DIV>
<A NAME="Heading115"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Precedence<BR><A NAME="Index496"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Operator precedence defines the order in
which an expression evaluates when several different operators are present. C
and C++ have specific rules to determine the order of evaluation. The easiest to
remember is that multiplication and division happen before addition and
subtraction. After that, if an expression isn&#8217;t transparent to you it
probably won&#8217;t be for anyone reading the code, so you should use
parentheses to make the order of evaluation explicit. For
example:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>A = X + Y - 2/2 + Z;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">has a very different meaning from the
same statement with a particular grouping of parentheses:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>A = X + (Y - 2)/(2 + Z);</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">(Try evaluating the result with X = 1, Y
= 2, and Z =
3.)</FONT><A NAME="_Toc462979752"></A><A NAME="_Toc472654758"></A><BR></P></DIV>
<A NAME="Heading116"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Auto increment <A NAME="Index497"></A>and decrement<A NAME="Index498"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C, and therefore C++, is full of
shortcuts. Shortcuts can make code much easier to type, and sometimes much
harder to read. Perhaps the C language designers thought it would be easier to
understand a tricky piece of code if your eyes didn&#8217;t have to scan as
large an area of print.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the nicer shortcuts is the
auto-increment<A NAME="Index499"></A> and auto-decrement<A NAME="Index500"></A>
operators. You often use these to change loop variables, which control the
number of times a loop executes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index501"></A><A NAME="Index502"></A><A NAME="Index503"></A><A NAME="Index504"></A><FONT FACE="Georgia">The
auto-decrement operator is &#8216;<B>--</B>&#8217; and means &#8220;decrease by
one unit.&#8221; The auto-increment operator is &#8216;<B>++</B>&#8217; and
means &#8220;increase by one unit.&#8221; If <B>A</B> is an <B>int</B>, for
example, the expression <B>++A</B> is equivalent to (<B>A = A + 1</B>).
Auto-increment and auto-decrement operators produce the value of the variable as
a result. If the operator appears before the variable, (i.e., <B>++A</B>), the
operation is first performed and the resulting value is produced. If the
operator appears after the variable (i.e. <B>A++</B>), the current value is
produced, and then the operation is performed. For example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:AutoIncrement.cpp</font>
<font color=#009900>// Shows use of auto-increment</font>
<font color=#009900>// and auto-decrement operators.</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i = 0;
  <font color=#0000ff>int</font> j = 0;
  cout &lt;&lt; ++i &lt;&lt; endl; <font color=#009900>// Pre-increment</font>
  cout &lt;&lt; j++ &lt;&lt; endl; <font color=#009900>// Post-increment</font>
  cout &lt;&lt; --i &lt;&lt; endl; <font color=#009900>// Pre-decrement</font>
  cout &lt;&lt; j-- &lt;&lt; endl; <font color=#009900>// Post decrement</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you&#8217;ve been wondering about the
name &#8220;<A NAME="Index505"></A>C++,&#8221; now you understand. It implies
&#8220;one step beyond
C.&#8221;</FONT><A NAME="_Toc462979753"></A><A NAME="_Toc472654759"></A><BR></P></DIV>
<A NAME="Heading117"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Introduction to data<A NAME="Index506"></A> types</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><I>Data types </I>define the way you use
storage (memory) in the programs you write. By specifying a data type, you tell
the compiler how to create a particular piece of storage, and also how to
manipulate that storage.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Data types can be
built-in<A NAME="Index507"></A> or abstract<A NAME="Index508"></A>. A built-in
data type<A NAME="Index509"></A> is one that the compiler intrinsically
understands, one that is wired directly into the compiler. The types of built-in
data are almost identical in C and C++. In contrast, a user-defined data
type<A NAME="Index510"></A><A NAME="Index511"></A> is one that you or another
programmer create as a class. These are commonly referred to as abstract data
types<A NAME="Index512"></A>. The compiler knows how to handle built-in types
when it starts up; it &#8220;learns&#8221; how to handle abstract data types by
reading header files<A NAME="Index513"></A> containing class declarations
(you&#8217;ll learn about this in later
chapters).</FONT><A NAME="_Toc462979754"></A><A NAME="_Toc472654760"></A><BR></P></DIV>
<A NAME="Heading118"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Basic built-in
types<A NAME="Index514"></A><A NAME="Index515"></A><BR><A NAME="Index516"></A><A NAME="Index517"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Standard C specification for built-in
types (which C++ inherits) doesn&#8217;t say how many bits each of the built-in
types must contain. Instead, it stipulates the minimum and maximum values that
the built-in type must be able to hold. When a machine is based on binary, this
maximum value can be directly translated into a minimum number of bits necessary
to hold that value. However, if a machine uses, for example, binary-coded
decimal (BCD) to represent numbers, then the amount of space in the machine
required to hold the maximum numbers for each data type will be different. The
minimum and maximum values that can be stored in the various data types are
defined in the system header files <B>limits.h<A NAME="Index518"></A> </B>and
<B>float.h<A NAME="Index519"></A></B> (in C++ you will generally <B>#include
&lt;climits&gt;</B> and <B>&lt;cfloat&gt;</B> instead).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C and C++ have four basic built-in data
types, described here for binary-based machines. A
<B>char<A NAME="Index520"></A><A NAME="Index521"></A></B> is for character
storage and uses a minimum of 8 bits (one byte) of storage, although it may be
larger. An <B>int<A NAME="Index522"></A><A NAME="Index523"></A></B> stores an
integral number and uses a minimum of two bytes of storage. The
<B>float<A NAME="Index524"></A><A NAME="Index525"></A></B> and
<B>double<A NAME="Index526"></A></B> types store floating-point
numbers<A NAME="Index527"></A>, usually in IEEE floating-point
format<A NAME="Index528"></A>. <B>float</B> is for single-precision floating
point<A NAME="Index529"></A> and <B>double</B> is for double-precision floating
point<A NAME="Index530"></A>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned previously, you can define
variables anywhere in a scope, and you can define and initialize
them<A NAME="Index531"></A><A NAME="Index532"></A> at the same time.
Here&#8217;s how to define variables using the four basic data
types:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Basic.cpp</font>
<font color=#009900>// Defining the four basic data</font>
<font color=#009900>// types in C and C++</font>

<font color=#0000ff>int</font> main() {
  <font color=#009900>// Definition without initialization:</font>
  <font color=#0000ff>char</font> protein;
  <font color=#0000ff>int</font> carbohydrates;
  <font color=#0000ff>float</font> fiber;
  <font color=#0000ff>double</font> fat;
  <font color=#009900>// Simultaneous definition &amp; initialization:</font>
  <font color=#0000ff>char</font> pizza = 'A', pop = 'Z';
  <font color=#0000ff>int</font> dongdings = 100, twinkles = 150, 
    heehos = 200;
  <font color=#0000ff>float</font> chocolate = 3.14159;
  <font color=#009900>// Exponential notation:</font>
  <font color=#0000ff>double</font> fudge_ripple = 6e-4; 
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first part of the program defines
variables of the four basic data types without initializing them. If you
don&#8217;t initialize a variable, the Standard says that its contents are
undefined (usually, this means they contain garbage). The second part of the
program defines and initializes variables at the same time (it&#8217;s always
best, if possible, to provide an initialization value at the point of
definition). Notice the use of exponential notation<A NAME="Index533"></A> in
the constant 6e-4, meaning &#8220;6 times 10 to the minus fourth
power.&#8221;</FONT><A NAME="_Toc312374157"></A><A NAME="_Toc462979755"></A><A NAME="_Toc472654761"></A><BR></P></DIV>
<A NAME="Heading119"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
bool, true, &amp; false</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Before <B>bool </B>became part of
Standard C++, everyone tended to use different techniques in order to produce
Boolean-like behavior.
<A NAME="Index534"></A><A NAME="Index535"></A><A NAME="Index536"></A><A NAME="Index537"></A><A NAME="Index538"></A><A NAME="Index539"></A>These
produced portability problems and could introduce subtle
errors.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The Standard C++ <B>bool</B> type can
have two states expressed by the built-in constants <B>true</B> (which converts
to an integral one) and <B>false</B> (which converts to an integral zero). All
three names are keywords. In addition, some language elements have been
adapted<A NAME="Index540"></A>:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=81 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>Element</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>Usage with bool</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=81 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&amp;&amp;   ||  
!</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Take bool arguments and produce
<B>bool</B> results.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=81 COLSPAN=1 ROWSPAN=1 VALIGN="MIDDLE">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&lt;   &gt;   &lt;=  &gt;=  ==  
!=</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="MIDDLE">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Produce <B>bool</B>
results.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=81 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>if</B>,<B> for</B>,<B>
</B></FONT><BR><FONT FACE="Georgia"><B>while</B>,<B> do</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Conditional expressions convert to
<B>bool</B> values.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=81 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>? :</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First operand converts to <B>bool</B>
value.</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because there&#8217;s a lot of existing
code that uses an <B>int</B> to represent a flag, the compiler will implicitly
convert from an <B>int</B> to a <B>bool</B> (nonzero values will produce <B>true
</B>while zero values produce <B>false</B>).<B> </B>Ideally, the compiler will
give you a warning as a suggestion to correct the situation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An idiom that falls under &#8220;poor
programming style&#8221; is the use of <B>++</B> to set a flag to true. This is
still allowed, but <A NAME="Index541"></A><I>deprecated</I>, which means that at
some time in the future it will be made illegal. The problem is that
you&#8217;re making an implicit type conversion from <B>bool</B> to <B>int</B>,
incrementing the value (perhaps beyond the range of the normal <B>bool</B>
values of zero and one), and then implicitly converting it back
again.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pointers (which will be introduced later
in this chapter) will also be automatically converted to <B>bool</B> when
necessary.</FONT><A NAME="_Toc462979756"></A><A NAME="_Toc472654762"></A><BR></P></DIV>
<A NAME="Heading120"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Specifiers<BR><A NAME="Index542"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Specifiers modify the meanings of the
basic built-in types and expand them to a much larger set. There are four
specifiers: <A NAME="Index543"></A><B>long<A NAME="Index544"></A></B>,
<A NAME="Index545"></A><B>short<A NAME="Index546"></A></B>,
<A NAME="Index547"></A><B>signed</B>,<A NAME="Index548"></A> and
<A NAME="Index549"></A><B>unsigned<A NAME="Index550"></A></B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>long</B> and <B>short</B> modify the
maximum and minimum values that a data type will hold. A plain <B>int</B> must
be at least the size of a <B>short</B>. The size hierarchy for integral types
is: <B>short</B> <B>int</B>, <B>int</B>, <B>long</B> <B>int</B>. All the sizes
could conceivably be the same, as long as they satisfy the minimum/maximum value
requirements. On a machine with a 64-bit word, for instance, all the data types
might be 64 bits.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The size hierarchy for floating point
numbers<A NAME="Index551"></A> is: <A NAME="Index552"></A><B>float</B>,
<A NAME="Index553"></A><B>double</B>, and
<A NAME="Index554"></A><A NAME="Index555"></A><B>long</B> <B>double</B>.
&#8220;<A NAME="Index556"></A>long float&#8221; is not a legal type. There are
no <B>short</B> floating-point numbers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>signed</B> and <B>unsigned</B>
specifiers tell the compiler how to use the sign bit with integral types and
characters (floating-point numbers always contain a sign). An <B>unsigned</B>
number does not keep track of the sign and thus has an extra bit available, so
it can store positive numbers twice as large as the positive numbers that can be
stored in a <B>signed</B> number. <B>signed</B> is the default and is only
necessary with <A NAME="Index557"></A><A NAME="Index558"></A><B>char</B>;
<B>char</B> may or may not default to <B>signed</B>. By specifying
<A NAME="Index559"></A><A NAME="Index560"></A><B>signed</B> <B>char</B>, you
force the sign bit to be used. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example shows the size of
the data types in bytes by using the
<A NAME="Index561"></A><A NAME="Index562"></A><B>sizeof</B> operator, introduced
later in this chapter:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Specify.cpp</font>
<font color=#009900>// Demonstrates the use of specifiers</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> cu;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> iu;
  <font color=#0000ff>short</font> <font color=#0000ff>int</font> is;
  <font color=#0000ff>short</font> iis; <font color=#009900>// Same as short int</font>
  <font color=#0000ff>unsigned</font> <font color=#0000ff>short</font> <font color=#0000ff>int</font> isu;
  <font color=#0000ff>unsigned</font> <font color=#0000ff>short</font> iisu;
  <font color=#0000ff>long</font> <font color=#0000ff>int</font> il;
  <font color=#0000ff>long</font> iil;  <font color=#009900>// Same as long int</font>
  <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> <font color=#0000ff>int</font> ilu;
  <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> iilu;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
  <font color=#0000ff>long</font> <font color=#0000ff>double</font> ld;
  cout 
    &lt;&lt; <font color=#004488>"\n char= "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(c)
    &lt;&lt; <font color=#004488>"\n unsigned char = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(cu)
    &lt;&lt; <font color=#004488>"\n int = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(i)
    &lt;&lt; <font color=#004488>"\n unsigned int = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(iu)
    &lt;&lt; <font color=#004488>"\n short = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(is)
    &lt;&lt; <font color=#004488>"\n unsigned short = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(isu)
    &lt;&lt; <font color=#004488>"\n long = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(il) 
    &lt;&lt; <font color=#004488>"\n unsigned long = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(ilu)
    &lt;&lt; <font color=#004488>"\n float = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(f)
    &lt;&lt; <font color=#004488>"\n double = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(d)
    &lt;&lt; <font color=#004488>"\n long double = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(ld) 
    &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Be aware that the results you get by
running this program will probably be different from one machine/operating
system/compiler to the next, since (as mentioned previously) the only thing that
must be consistent is that each different type hold the minimum and maximum
values specified in the Standard.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you are modifying an <B>int</B> with
<B>short</B> or <B>long</B>, the keyword <B>int</B> is optional, as shown
above.</FONT><A NAME="_Toc462979757"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index563"></A><A NAME="_Toc472654763"></A><BR></P></DIV>
<A NAME="Heading121"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Introduction to pointers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Whenever you run a program, it is first
loaded (typically from disk) into the computer&#8217;s memory. Thus, all
elements of your program are located somewhere in memory.
<A NAME="Index564"></A>Memory is typically laid out as a sequential series of
memory locations; we usually refer to these locations as eight-bit
<A NAME="Index565"></A><I>bytes </I>but actually the size of each space depends
on the architecture of the particular machine and is usually called that
machine&#8217;s <A NAME="Index566"></A><A NAME="Index567"></A><I>word size</I>.
Each space can be uniquely distinguished from all other spaces by its
<A NAME="Index568"></A><I>address</I>. For the purposes of this discussion,
we&#8217;ll just say that all machines use bytes that have sequential addresses
starting at zero and going up to however much memory you have in your
computer.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since your program lives in memory while
it&#8217;s being run, every element of your program has an address. Suppose we
start with a simple program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:YourPets1.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> dog, cat, bird, fish;

<font color=#0000ff>void</font> f(<font color=#0000ff>int</font> pet) {
  cout &lt;&lt; <font color=#004488>"pet id number: "</font> &lt;&lt; pet &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i, j, k;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each of the elements in this program has
a location in storage when the program is running. Even the function occupies
storage. As you&#8217;ll see, it turns out that what an element is and the way
you define it usually determines the area of memory where that element is
placed.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There is an operator in C and C++ that
will tell you the <A NAME="Index569"></A>address of an element. This is the
<A NAME="Index570"></A><A NAME="Index571"></A><A NAME="Index572"></A>
&#8216;<B>&amp;</B>&#8217; operator. All you do is precede the identifier name
with &#8216;<B>&amp;</B>&#8217; and it will produce the address of that
identifier. <B>YourPets1.cpp</B> can be modified to print out the addresses of
all its elements, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:YourPets2.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> dog, cat, bird, fish;

<font color=#0000ff>void</font> f(<font color=#0000ff>int</font> pet) {
  cout &lt;&lt; <font color=#004488>"pet id number: "</font> &lt;&lt; pet &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i, j, k;
  cout &lt;&lt; <font color=#004488>"f(): "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;f &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"dog: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;dog &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"cat: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;cat &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"bird: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;bird &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"fish: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;fish &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;i &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"j: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;j &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"k: "</font> &lt;&lt; (<font color=#0000ff>long</font>)&amp;k &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>(long)</B> is a
<A NAME="Index573"></A><A NAME="Index574"></A><I>cast</I>. It says
&#8220;Don&#8217;t treat this as if it&#8217;s normal type, instead treat it as
a <B>long</B>.&#8221; The cast isn&#8217;t essential, but if it wasn&#8217;t
there, the addresses would have been printed out in hexadecimal instead, so
casting to a <A NAME="Index575"></A><B>long</B> makes things a little more
readable.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The results of this program will vary
depending on your computer, OS, and all sorts of other factors, but it will
always give you some interesting insights. For a single run on my computer, the
results looked like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>f(): 4198736
dog: 4323632
cat: 4323636
bird: 4323640
fish: 4323644
i: 6684160
j: 6684156
k: 6684152</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see how the variables that are
defined inside <B>main(&#160;)</B> are in a different area than the variables
defined outside of <B>main(&#160;)</B>; you&#8217;ll understand why as you learn
more about the language. Also, <B>f(&#160;)</B> appears to be in its own area;
code is typically separated from data in memory.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another interesting thing to note is that
variables defined one right after the other appear to be placed contiguously in
memory. They are separated by the number of bytes that are required by their
data type. Here, the only data type used is <B>int</B>, and <B>cat</B> is four
bytes away from <B>dog</B>, <B>bird</B> is four bytes away from <B>cat</B>, etc.
So it would appear that, on this machine, an <B>int</B> is four bytes
long.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Other than this interesting experiment
showing how memory is mapped out, what can you do with an address? The most
important thing you can do is store it inside another variable for later use. C
and C++ have a special type of variable that holds an address. This variable is
called a <A NAME="Index576"></A><I>pointer</I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index577"></A><A NAME="Index578"></A><A NAME="Index579"></A><FONT FACE="Georgia">The
operator that defines a pointer is the same as the one used for multiplication:
&#8216;<B>*</B>&#8217;. The compiler knows that it isn&#8217;t multiplication
because of the context in which it is used, as you will see.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you define a pointer, you must
specify the type of variable it points to. You start out by giving the type
name, then instead of immediately giving an identifier for the variable, you say
&#8220;Wait, it&#8217;s a pointer&#8221; by inserting a star between the type
and the identifier. So a pointer to an <B>int</B> looks like
this:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>* ip; <font color=#009900>// ip points to an int variable</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The association of the
&#8216;<B>*</B>&#8217; with the type looks sensible and reads easily, but it can
actually be a bit deceiving. Your inclination might be to say
&#8220;intpointer&#8221; as if it is a single discrete type. However, with an
<B>int</B> or other basic data type, it&#8217;s possible to
say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> a, b, c;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">whereas with a pointer, you&#8217;d
<I>like</I> to say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>* ipa, ipb, ipc;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C syntax (and by inheritance, C++ syntax)
does not allow such sensible expressions. In the definitions above, only
<B>ipa</B> is a pointer, but <B>ipb</B> and <B>ipc</B> are ordinary <B>int</B>s
(you can say that &#8220;* binds more tightly to the identifier&#8221;).
Consequently, the best results can be achieved by using only one definition per
line; you still get the sensible syntax without the confusion:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>* ipa;
<font color=#0000ff>int</font>* ipb;
<font color=#0000ff>int</font>* ipc;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Since a general guideline for C++
programming is that you should always initialize a variable at the point of
definition, this form actually works better. For example, the variables above
are not initialized to any particular value; they hold garbage. It&#8217;s much
better to say something like:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> a = 47;
<font color=#0000ff>int</font>* ipa = &amp;a;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now both <B>a</B> and <B>ipa</B> have
been initialized, and <B>ipa</B> holds the address of <B>a</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you have an initialized pointer, the
most basic thing you can do with it is to use it to modify the value it points
to. To access a variable through a pointer, you
<A NAME="Index580"></A><I>dereference</I> the pointer using the same operator
that you used to define it, like this:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>*ipa = 100;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now <B>a</B> contains the value 100
instead of 47.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These are the basics of pointers: you can
hold an address, and you can use that address to modify the original variable.
But the question still remains: why do you want to modify one variable using
another variable as a proxy?</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For this introductory view of pointers,
we can put the answer into two broad categories:</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">To change &#8220;outside
objects&#8221; from within a function. This is perhaps the most basic use of
pointers, and it will be examined
here.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">To achieve
many other clever programming techniques, which you&#8217;ll learn about in
portions of the rest of the
book.</FONT><A NAME="_Toc462979758"></A><A NAME="_Toc472654764"></A></OL><A NAME="Heading122"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Modifying the outside object</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Ordinarily, when you pass an argument to
a function, a copy of that argument is made inside the function. This is
referred to as
<A NAME="Index581"></A><A NAME="Index582"></A><I>pass-by-value</I>.<I> </I>You
can see the effect of pass-by-value in the following program:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PassByValue.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> f(<font color=#0000ff>int</font> a) {
  cout &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; a &lt;&lt; endl;
  a = 5;
  cout &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; a &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> x = 47;
  cout &lt;&lt; <font color=#004488>"x = "</font> &lt;&lt; x &lt;&lt; endl;
  f(x);
  cout &lt;&lt; <font color=#004488>"x = "</font> &lt;&lt; x &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>f(&#160;)</B>, <B>a</B> is a
<A NAME="Index583"></A><A NAME="Index584"></A><I>local variable</I>, so it
exists only for the duration of the function call to <B>f(&#160;)</B>. Because
it&#8217;s a <A NAME="Index585"></A><A NAME="Index586"></A>function argument,
the value of <B>a</B> is initialized by the arguments that are passed when the
function is called; in <B>main(&#160;)</B> the argument is <B>x,</B> which has a
value of 47, so this value is copied into <B>a</B> when <B>f(&#160;)</B> is
called.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program you&#8217;ll
see:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x = 47
a = 47
a = 5
x = 47</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Initially, of course, <B>x</B> is 47.
When <B>f(&#160;)</B> is called, temporary space is created to hold the variable
<B>a</B> for the duration of the function call, and <B>a</B> is initialized by
copying the value of <B>x</B>, which is verified by printing it out. Of course,
you can change the value of <B>a</B> and show that it is changed. But when
<B>f(&#160;)</B> is completed, the temporary space that was created for <B>a</B>
disappears, and we see that the only connection that ever existed between
<B>a</B> and <B>x</B> happened when the value of <B>x</B> was copied into
<B>a</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you&#8217;re inside
<B>f(&#160;)</B>, <B>x</B> is the
<A NAME="Index587"></A><A NAME="Index588"></A><I>outside object</I> (my
terminology), and changing the local variable does not affect the outside
object, naturally enough, since they are two separate locations in storage. But
what if you <I>do</I> want to modify the outside object? This is where pointers
come in handy. In a sense, a pointer is an alias for another variable. So if we
pass a <I>pointer</I> into a function instead of an ordinary value, we are
actually passing an alias to the outside object, enabling the function to modify
that outside object, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PassAddress.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> f(<font color=#0000ff>int</font>* p) {
  cout &lt;&lt; <font color=#004488>"p = "</font> &lt;&lt; p &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"*p = "</font> &lt;&lt; *p &lt;&lt; endl;
  *p = 5;
  cout &lt;&lt; <font color=#004488>"p = "</font> &lt;&lt; p &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> x = 47;
  cout &lt;&lt; <font color=#004488>"x = "</font> &lt;&lt; x &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"&amp;x = "</font> &lt;&lt; &amp;x &lt;&lt; endl;
  f(&amp;x);
  cout &lt;&lt; <font color=#004488>"x = "</font> &lt;&lt; x &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now <B>f(&#160;)</B> takes a pointer as
an argument and dereferences the pointer during assignment, and this causes the
outside object <B>x</B> to be modified. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x = 47
&amp;x = 0065FE00
p = 0065FE00
*p = 47
p = 0065FE00
x = 5</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice that the value contained in <B>p
</B>is the same as the address of <B>x</B> &#8211; the pointer <B>p</B> does
indeed point to <B>x</B>. If that isn&#8217;t convincing enough, when <B>p</B>
is dereferenced to assign the value 5, we see that the value of <B>x</B> is now
changed to 5 as well.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Thus, passing a pointer into a function
will allow that function to modify the outside object. You&#8217;ll see plenty
of other uses for pointers later, but this is arguably the most basic and
possibly the most common
use.</FONT><A NAME="_Toc462979759"></A><A NAME="_Toc472654765"></A><BR></P></DIV>
<A NAME="Heading123"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Introduction to C++ <A NAME="Index589"></A>references</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pointers work roughly the same in C and
in C++, but C++ adds an additional way to pass an address into a function. This
is <A NAME="Index590"></A><I>pass-by-reference</I> and it exists in several
other programming languages so it was not a C++ invention.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Your initial perception of references may
be that they are unnecessary, that you could write all your programs without
references. In general, this is true, with the exception of a few important
places that you&#8217;ll learn about later in the book. You&#8217;ll also learn
more about references later, but the basic idea is the same as the demonstration
of pointer use above: you can pass the address of an argument using a reference.
The difference between references and <A NAME="Index591"></A>pointers is that
<I>calling</I> a function that takes references is cleaner, syntactically, than
calling a function that takes pointers (and it is exactly this syntactic
difference that makes references essential in certain situations). If
<B>PassAddress.cpp</B> is modified to use references, you can see the difference
in the function call in <B>main(&#160;)</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PassReference.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> f(<font color=#0000ff>int</font>&amp; r) {
  cout &lt;&lt; <font color=#004488>"r = "</font> &lt;&lt; r &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"&amp;r = "</font> &lt;&lt; &amp;r &lt;&lt; endl;
  r = 5;
  cout &lt;&lt; <font color=#004488>"r = "</font> &lt;&lt; r &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> x = 47;
  cout &lt;&lt; <font color=#004488>"x = "</font> &lt;&lt; x &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"&amp;x = "</font> &lt;&lt; &amp;x &lt;&lt; endl;
  f(x); <font color=#009900>// Looks like pass-by-value, </font>
        <font color=#009900>// is actually pass by reference</font>
  cout &lt;&lt; <font color=#004488>"x = "</font> &lt;&lt; x &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>f(&#160;)</B>&#8217;s argument
list, instead of saying <B>int*</B> to pass a pointer, you say <B>int&amp;</B>
to pass a reference. Inside <B>f(&#160;)</B>, if you just say
&#8216;<B>r</B>&#8217; (which would produce the address if <B>r</B> were a
pointer) you get <I>the value in the variable that <B>r </B>references</I>. If
you assign to <B>r</B>, you actually assign to the variable that <B>r</B>
references. In fact, the only way to get the address that&#8217;s held inside
<B>r</B> is with the &#8216;<B>&amp;</B>&#8217; operator.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, you can see the
key effect of references in the syntax of the call to <B>f(&#160;)</B>, which is
just <B>f(x)</B>. Even though this looks like an ordinary pass-by-value, the
effect of the reference is that it actually takes the address and passes it in,
rather than making a copy of the value. The output is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x = 47
&amp;x = 0065FE00
r = 47
&amp;r = 0065FE00
r = 5
x = 5</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So you can see that pass-by-reference
allows a function to modify the outside object, just like passing a pointer does
(you can also observe that the reference obscures the fact that an address is
being passed; this will be examined later in the book). Thus, for this simple
introduction you can assume that references are just a syntactically different
way (sometimes referred to as &#8220;syntactic sugar&#8221;) to accomplish the
same thing that pointers do: allow functions to change outside
objects.</FONT><A NAME="_Toc462979760"></A><A NAME="_Toc472654766"></A><BR></P></DIV>
<A NAME="Heading124"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Pointers and references as modifiers</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So far, you&#8217;ve seen the basic data
types <B>char</B>, <B>int</B>, <B>float,</B> and <B>double</B>, along with the
specifiers <B>signed</B>, <B>unsigned</B>, <B>short,</B> and <B>long</B>, which
can be used with the basic data types in almost any combination. Now we&#8217;ve
added pointers and references that are orthogonal to the basic data types and
specifiers, so the possible <A NAME="Index592"></A>combinations have just
tripled:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:AllDefinitions.cpp</font>
<font color=#009900>// All possible combinations of basic data types, </font>
<font color=#009900>// specifiers, pointers and references</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> f1(<font color=#0000ff>char</font> c, <font color=#0000ff>int</font> i, <font color=#0000ff>float</font> f, <font color=#0000ff>double</font> d);
<font color=#0000ff>void</font> f2(<font color=#0000ff>short</font> <font color=#0000ff>int</font> si, <font color=#0000ff>long</font> <font color=#0000ff>int</font> li, <font color=#0000ff>long</font> <font color=#0000ff>double</font> ld);
<font color=#0000ff>void</font> f3(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> uc, <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> ui, 
  <font color=#0000ff>unsigned</font> <font color=#0000ff>short</font> <font color=#0000ff>int</font> usi, <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> <font color=#0000ff>int</font> uli);
<font color=#0000ff>void</font> f4(<font color=#0000ff>char</font>* cp, <font color=#0000ff>int</font>* ip, <font color=#0000ff>float</font>* fp, <font color=#0000ff>double</font>* dp);
<font color=#0000ff>void</font> f5(<font color=#0000ff>short</font> <font color=#0000ff>int</font>* sip, <font color=#0000ff>long</font> <font color=#0000ff>int</font>* lip, 
  <font color=#0000ff>long</font> <font color=#0000ff>double</font>* ldp);
<font color=#0000ff>void</font> f6(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font>* ucp, <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font>* uip, 
  <font color=#0000ff>unsigned</font> <font color=#0000ff>short</font> <font color=#0000ff>int</font>* usip, 
  <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> <font color=#0000ff>int</font>* ulip);
<font color=#0000ff>void</font> f7(<font color=#0000ff>char</font>&amp; cr, <font color=#0000ff>int</font>&amp; ir, <font color=#0000ff>float</font>&amp; fr, <font color=#0000ff>double</font>&amp; dr);
<font color=#0000ff>void</font> f8(<font color=#0000ff>short</font> <font color=#0000ff>int</font>&amp; sir, <font color=#0000ff>long</font> <font color=#0000ff>int</font>&amp; lir, 
  <font color=#0000ff>long</font> <font color=#0000ff>double</font>&amp; ldr);
<font color=#0000ff>void</font> f9(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font>&amp; ucr, <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font>&amp; uir, 
  <font color=#0000ff>unsigned</font> <font color=#0000ff>short</font> <font color=#0000ff>int</font>&amp; usir, 
  <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> <font color=#0000ff>int</font>&amp; ulir);

<font color=#0000ff>int</font> main() {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pointers and references also work when
passing objects into and out of functions; you&#8217;ll learn about this in a
later chapter.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There&#8217;s one other type that works
with pointers: <B>void</B>. If you state that a pointer is
<A NAME="Index593"></A>a
<A NAME="Index594"></A><A NAME="Index595"></A><B>void*</B>, it means that any
type of address at all can be assigned to that pointer (whereas if you have an
<B>int*</B>, you can assign only the address of an <B>int</B> variable to that
pointer). For example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:VoidPointer.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>void</font>* vp;
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
  <font color=#009900>// The address of ANY type can be</font>
  <font color=#009900>// assigned to a void pointer:</font>
  vp = &amp;c;
  vp = &amp;i;
  vp = &amp;f;
  vp = &amp;d;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you assign to a <B>void*</B> you
lose any information about what type it is. This means that before you can use
the pointer, you must cast it to the correct type:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:CastFromVoidPointer.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i = 99;
  <font color=#0000ff>void</font>* vp = &amp;i;
  <font color=#009900>// Can't dereference a void pointer:</font>
  <font color=#009900>// *vp = 3; // Compile-time error</font>
  <font color=#009900>// Must cast back to int before dereferencing:</font>
  *((<font color=#0000ff>int</font>*)vp) = 3;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The cast <B>(int*)vp</B> takes the
<B>void*</B> and tells the compiler to treat it as an <B>int*</B>, and thus it
can be successfully dereferenced. You might observe that this syntax is ugly,
and it is, but it&#8217;s worse than that &#8211; the <B>void*</B> introduces a
hole in the language&#8217;s type system. That is, it allows, or even promotes,
the treatment of one type as another type. In the example above, I treat an
<B>int</B> as an <B>int</B> by casting <B>vp</B> to an <B>int*</B>, but
there&#8217;s nothing that says I can&#8217;t cast it to a <B>char*</B> or
<B>double*</B>, which would modify a different amount of storage that had been
allocated for the <B>int</B>, possibly crashing the program. In general,
<B>void</B> pointers should be avoided, and used only in rare special cases, the
likes of which you won&#8217;t be ready to consider until significantly later in
the book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You cannot have a
<A NAME="Index596"></A><A NAME="Index597"></A><A NAME="Index598"></A><B>void</B>
reference, for reasons that will be explained in Chapter
11.</FONT><A NAME="_Toc462979761"></A><A NAME="_Toc472654767"></A><BR></P></DIV>
<A NAME="Heading125"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Scoping<A NAME="Index599"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Scoping rules tell you where a variable
is valid, where it is created, and where it gets destroyed (i.e., goes out of
scope)<A NAME="Index600"></A><A NAME="Index601"></A><A NAME="Index602"></A>. The
scope of a variable extends from the point where it is defined to the first
closing brace that matches the closest opening brace before the variable was
defined. That is, a scope is defined by its &#8220;nearest&#8221; set of braces.
To illustrate:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Scope.cpp</font>
<font color=#009900>// How variables are scoped</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> scp1;
  <font color=#009900>// scp1 visible here</font>
  {
    <font color=#009900>// scp1 still visible here</font>
    <font color=#009900>//.....</font>
    <font color=#0000ff>int</font> scp2;
    <font color=#009900>// scp2 visible here</font>
    <font color=#009900>//.....</font>
    {
      <font color=#009900>// scp1 &amp; scp2 still visible here</font>
      <font color=#009900>//..</font>
      <font color=#0000ff>int</font> scp3;
      <font color=#009900>// scp1, scp2 &amp; scp3 visible here</font>
      <font color=#009900>// ...</font>
    } <font color=#009900>// &lt;-- scp3 destroyed here</font>
    <font color=#009900>// scp3 not available here</font>
    <font color=#009900>// scp1 &amp; scp2 still visible here</font>
    <font color=#009900>// ...</font>
  } <font color=#009900>// &lt;-- scp2 destroyed here</font>
  <font color=#009900>// scp3 &amp; scp2 not available here</font>
  <font color=#009900>// scp1 still visible here</font>
  <font color=#009900>//..</font>
} <font color=#009900>// &lt;-- scp1 destroyed here</font>
<font color=#009900>///:~ </font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The example above shows when variables
are visible and when they are unavailable (that is, when they <I>go out of
scope</I>). A variable can be used only when inside its scope. Scopes can be
nested<A NAME="Index603"></A>, indicated by matched pairs of braces inside other
matched pairs of braces. Nesting means that you can access a variable in a scope
that encloses the scope you are in. In the example above, the variable
<B>scp1</B> is available inside all of the other scopes, while <B>scp3</B> is
available only in the innermost
scope.</FONT><A NAME="_Toc462979762"></A><A NAME="_Toc472654768"></A><BR></P></DIV>
<A NAME="Heading126"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Defining variables on the fly</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As noted earlier in this chapter, there
is a significant difference between C and C++ when defining
variables<A NAME="Index604"></A><A NAME="Index605"></A><A NAME="Index606"></A><A NAME="Index607"></A>.
Both languages require that variables be defined before they are used, but C
(and many other traditional procedural languages) forces you to define all the
variables at the beginning of a scope, so that when the compiler creates a block
it can allocate space for those variables. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">While reading C code, a block of variable
definitions is usually the first thing you see when entering a scope. Declaring
all variables<A NAME="Index608"></A> at the beginning of the block requires the
programmer to write in a particular way because of the implementation details of
the language. Most people don&#8217;t know all the variables they are going to
use before they write the code, so they must keep jumping back to the beginning
of the block to insert new variables, which is awkward and causes errors. These
variable definitions don&#8217;t usually mean much to the reader, and they
actually tend to be confusing because they appear apart from the context in
which they are used.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C++ (not C) allows you to define
variables anywhere in a scope<A NAME="Index609"></A>, so you can define a
variable right before you use it. In addition, you can initialize the variable
at the point you define it, which prevents a certain class of errors. Defining
variables this way makes the code much easier to write and reduces the errors
you get from being forced to jump back and forth within a scope. It makes the
code easier to understand because you see a variable defined in the context of
its use. This is especially important when you are defining and initializing a
variable at the same time &#8211; you can see the meaning of the initialization
value by the way the variable is used.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also define variables inside the
control expressions of <A NAME="Index610"></A><B>for</B> loops and
<A NAME="Index611"></A><B>while</B> loops, inside the conditional of an
<A NAME="Index612"></A><B>if</B> statement, and inside the selector statement of
a <A NAME="Index613"></A><B>switch</B>. Here&#8217;s an example showing
on-the-fly variable definitions:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:OnTheFly.cpp</font>
<font color=#009900>// On-the-fly variable definitions</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#009900>//..</font>
  { <font color=#009900>// Begin a new scope</font>
    <font color=#0000ff>int</font> q = 0; <font color=#009900>// C requires definitions here</font>
    <font color=#009900>//..</font>
    <font color=#009900>// Define at point of use:</font>
    <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 100; i++) { 
      q++; <font color=#009900>// q comes from a larger scope</font>
      <font color=#009900>// Definition at the end of the scope:</font>
      <font color=#0000ff>int</font> p = 12; 
    }
    <font color=#0000ff>int</font> p = 1;  <font color=#009900>// A different p</font>
  } <font color=#009900>// End scope containing q &amp; outer p</font>
  cout &lt;&lt; <font color=#004488>"Type characters:"</font> &lt;&lt; endl;
  <font color=#0000ff>while</font>(<font color=#0000ff>char</font> c = cin.get() != 'q') {
    cout &lt;&lt; c &lt;&lt; <font color=#004488>" wasn't it"</font> &lt;&lt; endl;
    <font color=#0000ff>if</font>(<font color=#0000ff>char</font> x = c == 'a' || c == 'b')
      cout &lt;&lt; <font color=#004488>"You typed a or b"</font> &lt;&lt; endl;
    <font color=#0000ff>else</font>
      cout &lt;&lt; <font color=#004488>"You typed "</font> &lt;&lt; x &lt;&lt; endl;
  }
  cout &lt;&lt; <font color=#004488>"Type A, B, or C"</font> &lt;&lt; endl;
  <font color=#0000ff>switch</font>(<font color=#0000ff>int</font> i = cin.get()) {
    <font color=#0000ff>case</font> 'A': cout &lt;&lt; <font color=#004488>"Snap"</font> &lt;&lt; endl; <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> 'B': cout &lt;&lt; <font color=#004488>"Crackle"</font> &lt;&lt; endl; <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> 'C': cout &lt;&lt; <font color=#004488>"Pop"</font> &lt;&lt; endl; <font color=#0000ff>break</font>;
    <font color=#0000ff>default</font>: cout &lt;&lt; <font color=#004488>"Not A, B or C!"</font> &lt;&lt; endl;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the innermost scope, <B>p</B> is
defined right before the scope ends, so it is really a useless gesture (but it
shows you can define a variable anywhere). The <B>p</B> in the outer scope is in
the same situation.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The definition of <B>i</B> in the control
expression of the <B>for</B> loop is an example of being able to define a
variable <I>exactly</I> at the point you need it (you can do this only in C++).
The scope of <B>i</B> is the scope of the expression controlled by the
<B>for</B> loop, so you can turn around and re-use <B>i</B> in the next
<B>for</B> loop. This is a convenient and commonly-used idiom in C++; <B>i</B>
is the classic name for a loop counter and you don&#8217;t have to keep
inventing new names.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although the example also shows variables
defined within <B>while</B>, <B>if,</B> and <B>switch</B> statements, this kind
of definition is much less common than those in <B>for</B> expressions, possibly
because the syntax is so constrained. For example, you cannot have any
parentheses. That is, you cannot say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>while</font>((<font color=#0000ff>char</font> c = cin.get()) != 'q')</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The addition of the extra parentheses
would seem like an innocent and useful thing to do, and because you cannot use
them, the results are not what you might like. The problem occurs because
&#8216;<B>!=</B>&#8217; has a higher precedence than &#8216;<B>=</B>&#8217;, so
the <B>char</B> <B>c </B>ends up containing a <B>bool</B> converted to
<B>char</B>. When that&#8217;s printed, on many terminals you&#8217;ll see a
smiley-face character.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, you can consider the ability
to define variables within <B>while</B>, <B>if,</B> and <B>switch</B> statements
as being there for completeness, but the only place you&#8217;re likely to use
this kind of variable definition is in a <B>for</B> loop (where you&#8217;ll use
it quite
often).</FONT><A NAME="_Toc462979763"></A><A NAME="_Toc472654769"></A><BR></P></DIV>
<A NAME="Heading127"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Specifying storage allocation<A NAME="Index614"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When creating a variable, you have a
number of options to specify the lifetime of the variable, how the storage is
allocated for that variable, and how the variable is treated by the
compiler.</FONT><A NAME="_Toc462979764"></A><A NAME="_Toc472654770"></A><BR></P></DIV>
<A NAME="Heading128"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Global variables<BR><A NAME="Index615"></A><A NAME="Index616"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Global variables are defined outside all
function bodies and are available to all parts of the program (even code in
other files). Global variables are unaffected by scopes and are always available
(i.e., the lifetime of a global variable lasts until the program ends). If the
existence of a global variable in one file is declared using the
<A NAME="Index617"></A><A NAME="Index618"></A><B>extern</B> keyword in another
file, the data is available for use by the second file. Here&#8217;s an example
of the use of global variables:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Global.cpp</font>
<font color=#009900>//{L} Global2</font>
<font color=#009900>// Demonstration of global variables</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> globe;
<font color=#0000ff>void</font> func();
<font color=#0000ff>int</font> main() {
  globe = 12;
  cout &lt;&lt; globe &lt;&lt; endl;
  func(); <font color=#009900>// Modifies globe</font>
  cout &lt;&lt; globe &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a file that accesses
<B>globe</B> as an <B>extern</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Global2.cpp {O}</font>
<font color=#009900>// Accessing external global variables</font>
<font color=#0000ff>extern</font> <font color=#0000ff>int</font> globe;  
<font color=#009900>// (The linker resolves the reference)</font>
<font color=#0000ff>void</font> func() {
  globe = 47;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Storage for the variable <B>globe</B> is
created by the definition in <B>Global.cpp</B>, and that same variable is
accessed by the code in <B>Global2.cpp</B>. Since the code in <B>Global2.cpp</B>
is compiled separately from the code in <B>Global.cpp</B>, the compiler must be
informed that the variable exists elsewhere by the declaration </FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>extern</font> <font color=#0000ff>int</font> globe;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run the program, you&#8217;ll
see that the call to <B>func(&#160;)</B> does indeed affect the single global
instance of <B>globe</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>Global.cpp</B>, you can see the
special <A NAME="Index619"></A><A NAME="Index620"></A>comment tag (which is my
own design):</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//{L} Global2</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This says that to create the final
program, the object file with the name <B>Global2</B> must be linked in (there
is no extension because the extension names of object files differ from one
system to the next). In <B>Global2.cpp</B>, the first line has another special
comment tag <B>{O},</B> which says &#8220;Don&#8217;t try to create an
executable out of this file, it&#8217;s being compiled so that it can be linked
into some other executable.&#8221; The <B>ExtractCode.cpp</B> program in Volume
2 of this book (downloadable at <I>www.BruceEckel.com</I>) reads these tags and
creates the appropriate <B>makefile</B> so everything compiles properly
(you&#8217;ll learn about <B>makefile</B>s at the end of this
chapter).</FONT><A NAME="_Toc462979765"></A><A NAME="_Toc472654771"></A><BR></P></DIV>
<A NAME="Heading129"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Local variables<A NAME="Index621"></A><A NAME="Index622"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Local variables occur within a scope;
they are &#8220;local&#8221; to a function. They are often called
<A NAME="Index623"></A><A NAME="Index624"></A><I>automatic</I> variables because
they automatically come into being when the scope is entered and automatically
go away when the scope closes. The keyword
<A NAME="Index625"></A><B>auto<A NAME="Index626"></A></B> makes this explicit,
but local variables default to <B>auto</B> so it is never necessary to declare
something as an <B>auto</B>.</FONT><BR></P></DIV>
<A NAME="Heading130"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Register variables<BR><A NAME="Index627"></A><A NAME="Index628"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A register variable is a type of local
variable. The <A NAME="Index629"></A><B>register</B> keyword tells the compiler
&#8220;Make accesses to this variable as fast as possible.&#8221; Increasing the
access speed is implementation dependent, but, as the name suggests, it is often
done by placing the variable in a register. There is no guarantee that the
variable will be placed in a register or even that the access speed will
increase. It is a hint to the compiler.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are restrictions to the use of
<B>register</B> variables. You cannot take or compute the address of a
<B>register</B> variable. A <B>register</B> variable can be declared only within
a block (you cannot have global or <B>static</B> <B>register</B> variables). You
can, however, use a <B>register</B> variable as a formal argument in a function
(i.e., in the argument list).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, you shouldn&#8217;t try to
second-guess the compiler&#8217;s optimizer, since it will probably do a better
job than you can. Thus, the <B>register</B> keyword is best
avoided.</FONT><A NAME="_Toc462979766"></A><A NAME="_Toc472654772"></A><BR></P></DIV>
<A NAME="Heading131"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
static</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index630"></A><A NAME="Index631"></A><B>static</B> keyword has several
distinct meanings. Normally, variables defined local to a function disappear at
the end of the function scope. When you call the function again, storage for the
variables is created anew and the values are re-initialized. If you want a value
to be extant throughout the life of a program, you can define a function&#8217;s
local variable to be <B>static</B> and give it an initial value. The
initialization is performed only the first time the function is called, and the
data retains its value between function calls. This way, a function can
&#8220;remember&#8221; some piece of information between function
calls.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may wonder why a global variable
isn&#8217;t used instead. The beauty of a <B>static</B> variable is that it is
unavailable outside the scope of the function, so it can&#8217;t be
inadvertently changed. This localizes errors.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s an example of the use of
<B>static</B> variables:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Static.cpp</font>
<font color=#009900>// Using a static variable in a function</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> func() {
  <font color=#0000ff>static</font> <font color=#0000ff>int</font> i = 0;
  cout &lt;&lt; <font color=#004488>"i = "</font> &lt;&lt; ++i &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> x = 0; x &lt; 10; x++)
    func();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Each time <B>func</B>(&#160;) is called
in the for loop, it prints a different value. If the keyword <B>static</B> is
not used, the value printed will always be &#8216;1&#8217;.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second meaning of <B>static</B> is
related to the first in the &#8220;unavailable outside a certain scope&#8221;
sense. When <B>static</B> is applied to a function name or to a variable that is
outside of all functions, it means &#8220;This name is unavailable outside of
this file.&#8221; The function name or variable is local to the file; we say it
has<I> file
scope<A NAME="Index632"></A><A NAME="Index633"></A><A NAME="Index634"></A></I>.
As a demonstration, compiling and linking the following two files will cause a
linker error:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:FileStatic.cpp</font>
<font color=#009900>// File scope demonstration. Compiling and </font>
<font color=#009900>// linking this file with FileStatic2.cpp</font>
<font color=#009900>// will cause a linker error</font>

<font color=#009900>// File scope means only available in this file:</font>
<font color=#0000ff>static</font> <font color=#0000ff>int</font> fs; 

<font color=#0000ff>int</font> main() {
  fs = 1;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though the variable <B>fs</B> is
claimed to exist as an <B>extern<A NAME="Index635"></A></B> in the following
file, the linker won&#8217;t find it because it has been declared <B>static</B>
in <B>FileStatic.cpp</B>.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:FileStatic2.cpp {O}</font>
<font color=#009900>// Trying to reference fs</font>
<font color=#0000ff>extern</font> <font color=#0000ff>int</font> fs;
<font color=#0000ff>void</font> func() {
  fs = 100;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>static</B> specifier may also be
used inside a <B>class</B>. This explanation will be delayed until you learn to
create classes, later in the
book.</FONT><A NAME="_Toc462979767"></A><A NAME="_Toc472654773"></A><BR></P></DIV>
<A NAME="Heading132"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
extern</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index636"></A><A NAME="Index637"></A><B>extern</B> keyword has already
been briefly described and demonstrated. It tells the compiler that a variable
or a function exists, even if the compiler hasn&#8217;t yet seen it in the file
currently being compiled. This variable or function may be defined in another
file or further down in the current file. As an example of the
latter:<A NAME="Index638"></A><A NAME="Index639"></A></FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Forward.cpp</font>
<font color=#009900>// Forward function &amp; data declarations</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// This is not actually external, but the </font>
<font color=#009900>// compiler must be told it exists somewhere:</font>
<font color=#0000ff>extern</font> <font color=#0000ff>int</font> i; 
<font color=#0000ff>extern</font> <font color=#0000ff>void</font> func();
<font color=#0000ff>int</font> main() {
  i = 0;
  func();
}
<font color=#0000ff>int</font> i; <font color=#009900>// The data definition</font>
<font color=#0000ff>void</font> func() {
  i++;
  cout &lt;&lt; i;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When the compiler encounters the
declaration &#8216;<B>extern int i</B>&#8217;, it knows that the definition for
<B>i</B> must exist somewhere as a global variable. When the compiler reaches
the definition of <B>i</B>, no other declaration is visible, so it knows it has
found the same <B>i</B> declared earlier in the file. If you were to define
<B>i</B> as <B>static</B>, you would be telling the compiler that <B>i</B> is
defined globally (via the <B>extern</B>), but it also has file
scope<A NAME="Index640"></A> (via the <B>static</B>), so the compiler will
generate an error.</FONT><BR></P></DIV>
<A NAME="Heading133"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Linkage<A NAME="Index641"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To understand the behavior of C and C++
programs, you need to know about <I>linkage</I>. In an executing program, an
identifier is represented by storage in memory that holds a variable or a
compiled function body. Linkage describes this storage as it is seen by the
linker. There are two types of linkage: <I>internal
linkage<A NAME="Index642"></A></I> and <I>external
linkage<A NAME="Index643"></A></I>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Internal linkage means that storage is
created to represent the identifier only for the file being compiled. Other
files may use the same identifier name with internal linkage, or for a global
variable, and no conflicts will be found by the linker &#8211; separate storage
is created for each identifier. Internal linkage is specified by the keyword
<B>static</B> in C and C++.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">External linkage means that a single
piece of storage is created to represent the identifier for all files being
compiled. The storage is created once, and the linker must resolve all other
references to that storage. Global variables and function names have external
linkage. These are accessed from other files by declaring them with the keyword
<B>extern</B>. Variables defined outside all functions (with the exception of
<B>const</B> in C++) and function definitions default to external linkage. You
can specifically force them to have internal linkage using the <B>static</B>
keyword. You can explicitly state that an identifier has external linkage by
defining it with the <B>extern</B> keyword. Defining a variable or function with
<B>extern</B> is not necessary in C, but it is sometimes necessary for
<B>const</B> in C++.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Automatic (local) variables exist only
temporarily, on the stack, while a function is being called. The linker
doesn&#8217;t know about automatic
variables<A NAME="Index644"></A><A NAME="Index645"></A>, and so these have <I>no
linkage<A NAME="Index646"></A><A NAME="Index647"></A></I>.</FONT><A NAME="_Toc462979768"></A><A NAME="_Toc472654774"></A><BR></P></DIV>
<A NAME="Heading134"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Constants<BR><A NAME="Index648"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In old (pre-Standard) C, if you wanted to
make a constant, you had to use the
preprocessor<A NAME="Index649"></A>:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#define PI 3.14159</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Everywhere you used <B>PI</B>, the value
3.14159 was substituted by the preprocessor (you can still use this method in C
and C++). </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you use the preprocessor to create
constants, you place control of those constants outside the scope of the
compiler. No type checking<A NAME="Index650"></A> is performed on the name
<B>PI</B> and you can&#8217;t take the address of <B>PI</B> (so you can&#8217;t
pass a pointer<A NAME="Index651"></A> or a reference<A NAME="Index652"></A> to
<B>PI</B>). <B>PI</B> cannot be a variable of a user-defined type. The meaning
of <B>PI</B> lasts from the point it is defined to the end of the file; the
preprocessor doesn&#8217;t recognize scoping.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C++ introduces the concept of a named
constant<A NAME="Index653"></A><A NAME="Index654"></A> that is just like a
variable, except that its value cannot be changed. The modifier
<A NAME="Index655"></A><B>const<A NAME="Index656"></A></B> tells the compiler
that a name represents a constant. Any data type, built-in or user-defined, may
be defined as <B>const</B>. If you define something as <B>const</B> and then
attempt to modify it, the compiler will generate an error.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You must specify the type of a
<B>const</B>, like this:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>const</font> <font color=#0000ff>int</font> x = 10;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Standard C and C++, you can use a
named constant in an argument list, even if the argument it fills is a pointer
or a reference (i.e., you can take the address of a <B>const</B>). A
<B>const</B> has a scope, just like a regular variable, so you can
&#8220;hide&#8221; a <B>const</B> inside a function and be sure that the name
will not affect the rest of the program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>const</B> was taken from C++ and
incorporated into Standard C, albeit quite differently. In C, the compiler
treats a <B>const</B> just like a variable that has a special tag attached that
says &#8220;Don&#8217;t change me.&#8221; When you define a <B>const</B> in C,
the compiler creates storage for it, so if you define more than one <B>const</B>
with the same name in two different files (or put the definition in a header
file), the linker will generate error messages about conflicts. The intended use
of <B>const</B> in C is quite different from its intended use in C++ (in short,
it&#8217;s nicer in C++).</FONT><BR></P></DIV>
<A NAME="Heading135"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Constant values<BR><A NAME="Index657"></A><A NAME="Index658"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In C++, a <B>const</B> must always have
an initialization value (in C, this is not true). Constant values for built-in
types are expressed as decimal<A NAME="Index659"></A>,
octal<A NAME="Index660"></A>, hexadecimal<A NAME="Index661"></A>, or
floating-point numbers<A NAME="Index662"></A> (sadly, binary numbers were not
considered important), or as characters<A NAME="Index663"></A>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the absence of any other clues, the
compiler assumes a constant value is a decimal number. The numbers 47, 0, and
1101 are all treated as decimal numbers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A constant value with a leading 0 is
treated as an octal number (base 8). Base 8 numbers can contain only digits 0-7;
the compiler flags other digits as an error. A legitimate octal number is 017
(15 in base 10).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A constant value with a leading 0x is
treated as a hexadecimal number (base 16). Base 16 numbers contain the digits
0-9 and a-f or A-F. A legitimate hexadecimal number is 0x1fe (510 in base
10).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Floating point numbers can contain
decimal points and exponential<A NAME="Index664"></A> powers (represented by e,
which means &#8220;10 to the power of&#8221;). Both the decimal point and the
<B>e</B> are optional. If you assign a constant to a floating-point variable,
the compiler will take the constant value and convert it to a floating-point
number (this process is one form of what&#8217;s called <I>implicit type
conversion<A NAME="Index665"></A><A NAME="Index666"></A></I>). However, it is a
good idea to use either a decimal point or an <B>e</B> to remind the reader that
you are using a floating-point number; some older compilers also need the
hint.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Legitimate floating-point constant values
are: 1e4, 1.0001, 47.0, 0.0, and -1.159e-77. You can add suffixes to force the
type of floating-point number: <B>f</B> or <B>F</B> forces a <B>float</B>,
<B>L</B> or <B>l</B> forces a <B>long</B> <B>double</B>; otherwise the number
will be a
<B>double</B>.<A NAME="Index667"></A><A NAME="Index668"></A><A NAME="Index669"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index670"></A><A NAME="Index671"></A><FONT FACE="Georgia">Character
constants are characters surrounded by single quotes, as:
&#8216;<B>A</B>&#8217;, &#8216;<B>0</B>&#8217;, &#8216; &#8216;. Notice there is
a big difference between the character &#8216;<B>0</B>&#8217; (ASCII 96) and the
value <B>0</B>. Special characters are represented with the &#8220;backslash
escape&#8221;: &#8216;<B>\n</B>&#8217; (newline), &#8216;<B>\t</B>&#8217; (tab),
&#8216;<B>\\</B>&#8217; (backslash), &#8216;<B>\r</B>&#8217; (carriage return),
&#8216;<B>\"</B>&#8217; (double quotes), &#8216;<B>\'</B>&#8217; (single quote),
etc. You can also express char constants in octal: &#8216;<B>\17</B>&#8217; or
hexadecimal:
&#8216;<B>\xff</B>&#8217;.</FONT><A NAME="_Toc462979769"></A><A NAME="_Toc472654775"></A><BR></P></DIV>
<A NAME="Heading136"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
volatile<BR><A NAME="Index672"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Whereas the qualifier <B>const</B> tells
the compiler &#8220;This never changes&#8221; (which allows the compiler to
perform extra optimizations), the qualifier
<A NAME="Index673"></A><B>volatile</B> tells the compiler &#8220;You never know
when this will change,&#8221; and prevents the compiler from performing any
optimizations based on the stability of that variable. Use this keyword when you
read some value outside the control of your code, such as a register in a piece
of communication hardware. A <B>volatile</B> variable is always read whenever
its value is required, even if it was just read the line
before.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A special case of some storage being
&#8220;outside the control of your code&#8221; is in a multithreaded program. If
you&#8217;re watching a particular flag that is modified by another thread or
process, that flag should be <B>volatile</B> so the compiler doesn&#8217;t make
the assumption that it can optimize away multiple reads of the
flag.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>volatile</B> may have no
effect when a compiler is not optimizing, but may prevent critical bugs when you
start optimizing the code (which is when the compiler will begin looking for
redundant reads).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>const</B> and <B>volatile
</B>keywords will be further illuminated in a later
chapter.</FONT><A NAME="_Toc462979770"></A><A NAME="_Toc472654776"></A><BR></P></DIV>
<A NAME="Heading137"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Operators and their
use<A NAME="Index674"></A><A NAME="Index675"></A><A NAME="Index676"></A></H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This section covers all the operators in
C and C++.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All operators produce a value from their
operands. This value is produced without modifying the operands, except with the
assignment, increment, and decrement operators. Modifying an operand is called a
<I>side effect<A NAME="Index677"></A></I>. The most common use for operators
that modify their operands is to generate the side effect, but you should keep
in mind that the value produced is available for your use just as in operators
without side
effects.</FONT><A NAME="_Toc462979771"></A><A NAME="_Toc472654777"></A><BR></P></DIV>
<A NAME="Heading138"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Assignment<A NAME="Index678"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Assignment is performed with the operator
<A NAME="Index679"></A><B>=</B>. It means &#8220;Take the right-hand side (often
called the <I>rvalue<A NAME="Index680"></A></I>) and copy it into the left-hand
side (often called the <I>lvalue<A NAME="Index681"></A></I>).&#8221; An rvalue
is any constant, variable, or expression that can produce a value, but an lvalue
must be a distinct, named variable (that is, there must be a physical space in
which to store data). For instance, you can assign a constant value to a
variable (<B>A = 4;</B>), but you cannot assign anything to constant value
&#8211; it cannot be an lvalue (you can&#8217;t say <B>4 =
A;</B>).</FONT><A NAME="_Toc462979772"></A><A NAME="_Toc472654778"></A><BR></P></DIV>
<A NAME="Heading139"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Mathematical operators<A NAME="Index682"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The basic mathematical operators are the
same as the ones available in most programming languages: addition
<A NAME="Index683"></A>(<A NAME="Index684"></A><B>+</B>),
subtraction<A NAME="Index685"></A> (<A NAME="Index686"></A><B>-</B>),
division<A NAME="Index687"></A> (<A NAME="Index688"></A><B>/</B>),
multiplication<A NAME="Index689"></A> (<A NAME="Index690"></A><B>*</B>), and
modulus<A NAME="Index691"></A> (<A NAME="Index692"></A><B>%</B>; this produces
the remainder from integer division). Integer division truncates the result (it
doesn&#8217;t round). The modulus operator cannot be used with floating-point
numbers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C and C++ also use a shorthand notation
to perform an operation and an assignment at the same time. This is denoted by
an operator followed by an equal sign, and is consistent with all the operators
in the language (whenever it makes sense). For example, to add 4 to the variable
<B>x</B> and assign <B>x</B> to the result, you say: <B>x += 4;</B>.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example shows the use of the
mathematical operators:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Mathops.cpp</font>
<font color=#009900>// Mathematical operators</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// A macro to display a string and a value.</font>
#define PRINT(STR, VAR) \
  cout &lt;&lt; STR <font color=#004488>" = "</font> &lt;&lt; VAR &lt;&lt; endl

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i, j, k;
  <font color=#0000ff>float</font> u, v, w;  <font color=#009900>// Applies to doubles, too</font>
  cout &lt;&lt; <font color=#004488>"enter an integer: "</font>;
  cin &gt;&gt; j;
  cout &lt;&lt; <font color=#004488>"enter another integer: "</font>;
  cin &gt;&gt; k;
  PRINT(<font color=#004488>"j"</font>,j);  PRINT(<font color=#004488>"k"</font>,k);
  i = j + k; PRINT(<font color=#004488>"j + k"</font>,i);
  i = j - k; PRINT(<font color=#004488>"j - k"</font>,i);
  i = k / j; PRINT(<font color=#004488>"k / j"</font>,i);
  i = k * j; PRINT(<font color=#004488>"k * j"</font>,i);
  i = k % j; PRINT(<font color=#004488>"k % j"</font>,i);
  <font color=#009900>// The following only works with integers:</font>
  j %= k; PRINT(<font color=#004488>"j %= k"</font>, j);
  cout &lt;&lt; <font color=#004488>"Enter a floating-point number: "</font>;
  cin &gt;&gt; v;
  cout &lt;&lt; <font color=#004488>"Enter another floating-point number:"</font>;
  cin &gt;&gt; w;
  PRINT(<font color=#004488>"v"</font>,v); PRINT(<font color=#004488>"w"</font>,w);
  u = v + w; PRINT(<font color=#004488>"v + w"</font>, u);
  u = v - w; PRINT(<font color=#004488>"v - w"</font>, u);
  u = v * w; PRINT(<font color=#004488>"v * w"</font>, u);
  u = v / w; PRINT(<font color=#004488>"v / w"</font>, u);
  <font color=#009900>// The following works for ints, chars, </font>
  <font color=#009900>// and doubles too:</font>
  PRINT(<font color=#004488>"u"</font>, u); PRINT(<font color=#004488>"v"</font>, v);
  u += v; PRINT(<font color=#004488>"u += v"</font>, u);
  u -= v; PRINT(<font color=#004488>"u -= v"</font>, u);
  u *= v; PRINT(<font color=#004488>"u *= v"</font>, u);
  u /= v; PRINT(<font color=#004488>"u /= v"</font>, u);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rvalues of all the assignments can,
of course, be much more complex.</FONT><BR></P></DIV>
<A NAME="Heading140"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Introduction to preprocessor
macros<A NAME="Index693"></A><A NAME="Index694"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice the use of the macro
<B>PRINT(&#160;)</B> to save typing (and typing errors!). Preprocessor macros
are traditionally named with all uppercase letters so they stand out &#8211;
you&#8217;ll learn later that macros can quickly become dangerous (and they can
also be very useful). </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The arguments in the parenthesized list
following the macro name are substituted in all the code following the closing
parenthesis. The preprocessor removes the name <B>PRINT</B> and substitutes the
code wherever the macro is called, so the compiler cannot generate any error
messages using the macro name, and it doesn&#8217;t do any type checking on the
arguments (the latter can be beneficial, as shown in the debugging macros at the
end of the
chapter).</FONT><A NAME="_Toc462979773"></A><A NAME="_Toc472654779"></A><BR></P></DIV>
<A NAME="Heading141"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Relational operators<A NAME="Index695"></A><A NAME="Index696"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Relational operators establish a
relationship between the values of the operands. They produce a Boolean
(specified with the <B>bool </B>keyword in C++) <B>true</B> if the relationship
is true, and <B>false </B>if the relationship is false. The relational operators
are: less than (<B>&lt;</B>)<A NAME="Index697"></A>, greater than
(<B>&gt;</B>)<A NAME="Index698"></A>, less than or equal to
(<B>&lt;=</B>)<A NAME="Index699"></A>, greater than or equal to
(<B>&gt;=</B>)<A NAME="Index700"></A>, equivalent
(<B>==</B>),<A NAME="Index701"></A> and not equivalent
(<B>!=</B>)<A NAME="Index702"></A>.<A NAME="Index703"></A><A NAME="Index704"></A><A NAME="Index705"></A><A NAME="Index706"></A><A NAME="Index707"></A><A NAME="Index708"></A>
They may be used with all built-in data types in C and C++. They may be given
special definitions for user-defined data types in C++ (you&#8217;ll learn about
this in Chapter 12, which covers operator
overloading).</FONT><A NAME="_Toc462979774"></A><A NAME="_Toc472654780"></A><BR></P></DIV>
<A NAME="Heading142"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Logical operators<A NAME="Index709"></A><A NAME="Index710"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The logical operators <I>and</I>
(<A NAME="Index711"></A><B>&amp;&amp;</B>)<A NAME="Index712"></A><A NAME="Index713"></A>
and <I>or</I>
(<A NAME="Index714"></A><B>||</B>)<A NAME="Index715"></A><A NAME="Index716"></A>
produce a <B>true</B> or <B>false</B>
<A NAME="Index717"></A><A NAME="Index718"></A><A NAME="Index719"></A>based on
the logical relationship of its arguments. Remember that in C and C++, a
statement is <B>true</B> if it has a non-zero value, and <B>false</B> if it has
a value of zero. If you print a <B>bool</B>, you&#8217;ll typically see a
&#8216;<B>1</B>&#8217; for <B>true</B> and &#8216;<B>0</B>&#8217; for
<B>false</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example uses the relational and
logical operators:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Boolean.cpp</font>
<font color=#009900>// Relational and logical operators.</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i,j;
  cout &lt;&lt; <font color=#004488>"Enter an integer: "</font>;
  cin &gt;&gt; i;
  cout &lt;&lt; <font color=#004488>"Enter another integer: "</font>;
  cin &gt;&gt; j;
  cout &lt;&lt; <font color=#004488>"i &gt; j is "</font> &lt;&lt; (i &gt; j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i &lt; j is "</font> &lt;&lt; (i &lt; j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i &gt;= j is "</font> &lt;&lt; (i &gt;= j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i &lt;= j is "</font> &lt;&lt; (i &lt;= j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i == j is "</font> &lt;&lt; (i == j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i != j is "</font> &lt;&lt; (i != j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i &amp;&amp; j is "</font> &lt;&lt; (i &amp;&amp; j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"i || j is "</font> &lt;&lt; (i || j) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>" (i &lt; 10) &amp;&amp; (j &lt; 10) is "</font>
       &lt;&lt; ((i &lt; 10) &amp;&amp; (j &lt; 10))  &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can replace the definition for
<B>int</B> with <B>float</B> or <B>double</B> in the program above. Be aware,
however, that the comparison of a floating-point number with the value of zero
is strict; a number that is the tiniest fraction different from another number
is still &#8220;not equal.&#8221; A floating-point number that is the tiniest
bit above zero is still
true.<A NAME="Index720"></A><A NAME="Index721"></A></FONT><A NAME="_Toc462979775"></A><A NAME="_Toc472654781"></A><BR></P></DIV>
<A NAME="Heading143"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Bitwise operators<A NAME="Index722"></A><A NAME="Index723"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The bitwise operators allow you to
manipulate individual bits in a number (since floating point values use a
special internal format, the bitwise operators work only with integral types:
<B>char</B>, <B>int</B> and <B>long</B>). Bitwise operators perform Boolean
algebra<A NAME="Index724"></A> on the corresponding bits in the arguments to
produce the result.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The bitwise
<A NAME="Index725"></A><I>and</I> operator
(<B>&amp;</B>)<A NAME="Index726"></A><A NAME="Index727"></A> produces a one in
the output bit if both input bits are one; otherwise it produces a zero. The
bitwise <A NAME="Index728"></A>or operator
(<B>|</B>)<A NAME="Index729"></A><A NAME="Index730"></A> produces a one in the
output bit if either input bit is a one and produces a zero only if both input
bits are zero. The bitwise <I>exclusive or</I>, or <I>xor</I>
(<B>^</B>)<A NAME="Index731"></A><A NAME="Index732"></A><A NAME="Index733"></A>
produces a one in the output bit if one or the other input bit is a one, but not
both. The bitwise <A NAME="Index734"></A><I>not<A NAME="Index735"></A>
</I>(<A NAME="Index736"></A><B>~</B>, also called the <I>ones complement</I>
operator<A NAME="Index737"></A><A NAME="Index738"></A>) is a unary
operator<A NAME="Index739"></A><A NAME="Index740"></A> &#8211; it only takes one
argument (all other bitwise operators are binary
operators<A NAME="Index741"></A><A NAME="Index742"></A>). Bitwise <I>not</I>
produces the opposite of the input bit &#8211; a one if the input bit is zero, a
zero if the input bit is one.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Bitwise operators can be combined with
the <B>=</B> sign to unite the operation and assignment:
<B>&amp;=<A NAME="Index743"></A></B>, <B>|=,<A NAME="Index744"></A></B> and
<B>^=<A NAME="Index745"></A></B> are all legitimate operations (since <B>~</B>
is a unary operator it cannot be combined with the <B>=</B>
sign).</FONT><A NAME="_Toc462979776"></A><A NAME="_Toc472654782"></A><BR></P></DIV>
<A NAME="Heading144"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Shift operators<A NAME="Index746"></A><A NAME="Index747"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The shift operators also manipulate bits.
The left-shift operator
(<B>&lt;&lt;</B>)<A NAME="Index748"></A><A NAME="Index749"></A> produces the
operand to the left of the operator shifted to the left by the number of bits
specified after the operator. The right-shift operator
(<B>&gt;&gt;</B>)<A NAME="Index750"></A><A NAME="Index751"></A> produces the
operand to the left of the operator shifted to the right by the number of bits
specified after the operator. If the value after the shift operator is greater
than the number of bits in the left-hand operand, the result is undefined. If
the left-hand operand is unsigned, the right shift is a logical shift so the
upper bits will be filled with zeros. If the left-hand operand is signed, the
right shift may or may not be a logical shift (that is, the behavior is
undefined).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Shifts can be combined with the equal
sign (<B>&lt;&lt;=</B> and
<B>&gt;&gt;=</B>)<A NAME="Index752"></A><A NAME="Index753"></A>. The lvalue is
replaced by the lvalue shifted by the rvalue.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What follows is an example that
demonstrates the use of all the operators involving bits. First, here&#8217;s a
general-purpose function that prints a byte in binary format, created separately
so that it may be easily reused. The header file declares the
function:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:printBinary.h</font>
<font color=#009900>// Display a byte in binary</font>
<font color=#0000ff>void</font> printBinary(<font color=#0000ff>const</font> <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> val);
<font color=#009900>///:~ </font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s the implementation of the
function:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:printBinary.cpp {O}</font>
#include &lt;iostream&gt;
<font color=#0000ff>void</font> printBinary(<font color=#0000ff>const</font> <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> val) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 7; i &gt;= 0; i--)
    <font color=#0000ff>if</font>(val &amp; (1 &lt;&lt; i))
      std::cout &lt;&lt; <font color=#004488>"1"</font>;
    <font color=#0000ff>else</font>
      std::cout &lt;&lt; <font color=#004488>"0"</font>;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>printBinary(&#160;)</B> function
takes a single byte and displays it bit-by-bit.  The expression
</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>(1 &lt;&lt; i) </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">produces a one in each successive bit
position; in binary: 00000001, 00000010, etc. If this bit is bitwise
<I>and</I>ed with <B>val</B> and the result is nonzero, it means there was a one
in that position in <B>val</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Finally, the function is used in the
example that shows the bit-manipulation operators:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Bitwise.cpp</font>
<font color=#009900>//{L} printBinary</font>
<font color=#009900>// Demonstration of bit manipulation</font>
#include <font color=#004488>"printBinary.h"</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// A macro to save typing:</font>
#define PR(STR, EXPR) \
  cout &lt;&lt; STR; printBinary(EXPR); cout &lt;&lt; endl;  

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>unsigned</font> <font color=#0000ff>int</font> getval;
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> a, b;
  cout &lt;&lt; <font color=#004488>"Enter a number between 0 and 255: "</font>;
  cin &gt;&gt; getval; a = getval;
  PR(<font color=#004488>"a in binary: "</font>, a);
  cout &lt;&lt; <font color=#004488>"Enter a number between 0 and 255: "</font>;
  cin &gt;&gt; getval; b = getval;
  PR(<font color=#004488>"b in binary: "</font>, b);
  PR(<font color=#004488>"a | b = "</font>, a | b);
  PR(<font color=#004488>"a &amp; b = "</font>, a &amp; b);
  PR(<font color=#004488>"a ^ b = "</font>, a ^ b);
  PR(<font color=#004488>"~a = "</font>, ~a);
  PR(<font color=#004488>"~b = "</font>, ~b);
  <font color=#009900>// An interesting bit pattern:</font>
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> c = 0x5A; 
  PR(<font color=#004488>"c in binary: "</font>, c);
  a |= c;
  PR(<font color=#004488>"a |= c; a = "</font>, a);
  b &amp;= c;
  PR(<font color=#004488>"b &amp;= c; b = "</font>, b);
  b ^= a;
  PR(<font color=#004488>"b ^= a; b = "</font>, b);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once again, a preprocessor macro is used
to save typing. It prints the string of your choice, then the binary
representation of an expression, then a newline.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, the variables are
<B>unsigned</B>. This is because, in general, you don't want signs when you are
working with bytes. An <B>int</B> must be used instead of a <B>char</B> for
<B>getval </B>because the &#8220;<B>cin &gt;&gt;</B>&#8221; statement will
otherwise treat the first digit as a character.  By assigning <B>getval</B> to
<B>a</B> and <B>b</B>, the value is converted to a single byte (by truncating
it).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>&lt;&lt;</B> and <B>&gt;&gt;</B>
provide <A NAME="Index754"></A>bit-shifting behavior, but when they shift bits
off the end of the number, those bits are lost (it&#8217;s commonly said that
they fall into the mythical <A NAME="Index755"></A><A NAME="Index756"></A><I>bit
bucket</I>, a place where discarded bits end up, presumably so they can be
reused...). When manipulating bits you can also perform
<A NAME="Index757"></A><I>rotation</I>, which means that the bits that fall off
one end are inserted back at the other end, as if they&#8217;re being rotated
around a loop. Even though most computer processors provide a machine-level
rotate command (so you&#8217;ll see it in the assembly language for that
processor), there is no direct support for &#8220;rotate&#8221; in C or C++.
<A NAME="Index758"></A>Presumably the designers of C felt justified in leaving
&#8220;rotate&#8221; off (aiming, as they said, for a minimal language) because
you can build your own rotate command. For example, here are functions to
perform left and right rotations:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Rotation.cpp {O}</font>
<font color=#009900>// Perform left and right rotations</font>

<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> rol(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> val) {
  <font color=#0000ff>int</font> highbit;
  <font color=#0000ff>if</font>(val &amp; 0x80) <font color=#009900>// 0x80 is the high bit only</font>
    highbit = 1;
  <font color=#0000ff>else</font>
    highbit = 0;
  <font color=#009900>// Left shift (bottom bit becomes 0):</font>
  val &lt;&lt;= 1;
  <font color=#009900>// Rotate the high bit onto the bottom:</font>
  val |= highbit;
  <font color=#0000ff>return</font> val;
}

<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> ror(<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font> val) {
  <font color=#0000ff>int</font> lowbit;
  <font color=#0000ff>if</font>(val &amp; 1) <font color=#009900>// Check the low bit</font>
    lowbit = 1;
  <font color=#0000ff>else</font>
    lowbit = 0;
  val &gt;&gt;= 1; <font color=#009900>// Right shift by one position</font>
  <font color=#009900>// Rotate the low bit onto the top:</font>
  val |= (lowbit &lt;&lt; 7);
  <font color=#0000ff>return</font> val;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Try using these functions in
<B>Bitwise.cpp</B>. Notice the definitions (or at least declarations) of
<B>rol(&#160;)</B> and <B>ror(&#160;)</B> must be seen by the compiler in
<B>Bitwise.cpp</B> before the functions are used.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The bitwise functions are generally
extremely efficient to use because they translate directly into assembly
language statements. Sometimes a single C or C++ statement will generate a
single line of assembly
code.</FONT><A NAME="_Toc462979777"></A><A NAME="_Toc472654783"></A><BR></P></DIV>
<A NAME="Heading145"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Unary operators<A NAME="Index759"></A><A NAME="Index760"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Bitwise <I>not</I> isn&#8217;t the only
operator that takes a single argument. Its companion, the <I>logical not</I>
(<B>!</B>)<A NAME="Index761"></A><A NAME="Index762"></A>, will take a
<B>true</B> value and produce a <B>false</B>
value<A NAME="Index763"></A><A NAME="Index764"></A><A NAME="Index765"></A>. The
unary minus (<B>-</B>)<A NAME="Index766"></A><A NAME="Index767"></A> and unary
plus (<B>+</B>)<A NAME="Index768"></A><A NAME="Index769"></A> are the same
operators as binary minus and plus; the compiler figures out which usage is
intended by the way you write the expression. For instance, the
statement</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x = -a;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">has an obvious meaning. The compiler can
figure out:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x = a * -b;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">but the reader might get confused, so it
is safer to say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x = a * (-b);</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The unary minus produces the negative of
the value. Unary plus provides symmetry with unary minus, although it
doesn&#8217;t actually do anything.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The increment<A NAME="Index770"></A> and
decrement<A NAME="Index771"></A><A NAME="Index772"></A><A NAME="Index773"></A>
operators (<B>++</B> and <B>--</B>) were introduced earlier in this chapter.
These are the only operators other than those involving assignment that have
side effects<A NAME="Index774"></A>. These operators increase or decrease the
variable by one unit, although &#8220;unit&#8221; can have different meanings
according to the data type &#8211; this is especially true with
pointers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index775"></A><A NAME="Index776"></A><FONT FACE="Georgia">The
last unary operators are the address-of
(<B>&amp;</B>)<A NAME="Index777"></A><A NAME="Index778"></A>, dereference
(<B>*</B> and <B>-&gt;</B>),<A NAME="Index779"></A> and
cast<A NAME="Index780"></A> operators in C and C++, and
<B>new<A NAME="Index781"></A></B> and <B>delete<A NAME="Index782"></A></B> in
C++. Address-of and dereference are used with pointers<A NAME="Index783"></A>,
described in this chapter. Casting is described later in this chapter, and
<B>new</B> and <B>delete</B> are introduced in Chapter
4.</FONT><A NAME="_Toc462979778"></A><A NAME="_Toc472654784"></A><BR></P></DIV>
<A NAME="Heading146"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The ternary
operator<BR><A NAME="Index784"></A><A NAME="Index785"></A><A NAME="Index786"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <A NAME="Index787"></A>ternary
<A NAME="Index788"></A><B>if-else</B> is unusual because it has three operands.
It is truly an operator because it produces a value, unlike the ordinary
<B>if-else</B> statement<A NAME="Index789"></A>. It consists of three
expressions: if the first expression (followed by a <B>?</B>) evaluates to
<B>true</B>, the expression following the <B>?</B> is evaluated and its result
becomes the value produced by the operator. If the first expression is
<B>false</B>, the third expression (following a <B>:</B>) is executed and its
result becomes the value produced by the operator.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The conditional operator can be used for
its side effects or for the value it produces. Here&#8217;s a code fragment that
demonstrates both:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a = --b ? b : (b = -99);</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, the conditional produces the
rvalue. <B>a</B> is assigned to the value of <B>b</B> if the result of
decrementing <B>b</B> is nonzero. If <B>b</B> became zero, <B>a</B> and <B>b</B>
are both assigned to -99. <B>b</B> is always decremented, but it is assigned to
-99 only if the decrement causes <B>b</B> to become 0. A similar statement can
be used without the &#8220;<B>a =</B>&#8221; just for its side
effects:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>--b ? b : (b = -99);</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here the second B is superfluous, since
the value produced by the operator is unused. An expression is required between
the <B>?</B> and <B>:</B>. In this case, the expression could simply be a
constant that might make the code run a bit
faster.</FONT><A NAME="_Toc462979779"></A><A NAME="_Toc472654785"></A><BR></P></DIV>
<A NAME="Heading147"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The comma operator<A NAME="Index790"></A><A NAME="Index791"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The comma is not restricted to separating
variable names in multiple definitions, such as </FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> i, j, k;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course, it&#8217;s also used in
function argument lists. However, it can also be used as an operator to separate
expressions &#8211; in this case it produces only the value of the last
expression. All the rest of the expressions in the comma-separated list are
evaluated only for their side effects. This example increments a list of
variables and uses the last one as the rvalue:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:CommaOperator.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a = 0, b = 1, c = 2, d = 3, e = 4;
  a = (b++, c++, d++, e++);
  cout &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; a &lt;&lt; endl;
  <font color=#009900>// The parentheses are critical here. Without</font>
  <font color=#009900>// them, the statement will evaluate to:</font>
  (a = b++), c++, d++, e++;
  cout &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; a &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In general, it&#8217;s best to avoid
using the comma as anything other than a separator, since people are not used to
seeing it as an
operator.</FONT><A NAME="_Toc462979780"></A><A NAME="_Toc472654786"></A><BR></P></DIV>
<A NAME="Heading148"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Common pitfalls when using
operators<BR><A NAME="Index792"></A><A NAME="Index793"></A><A NAME="Index794"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As illustrated above, one of the pitfalls
when using operators is trying to get away without parentheses when you are even
the least bit uncertain about how an expression will evaluate (consult your
local C manual for the order of expression evaluation).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Another extremely common error looks like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Pitfall.cpp</font>
<font color=#009900>// Operator mistakes</font>

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a = 1, b = 1;
  <font color=#0000ff>while</font>(a = b) {
    <font color=#009900>// ....</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The statement <B>a = b</B> will always
evaluate to true<A NAME="Index795"></A> when <B>b</B> is non-zero. The variable
<B>a </B>is assigned to the value of <B>b</B>, and the value of <B>b</B> is also
produced by the operator <B>=<A NAME="Index796"></A></B>. In general, you want
to use the equivalence<A NAME="Index797"></A><A NAME="Index798"></A> operator
<B>==</B> inside a conditional statement, not assignment. This one bites a lot
of programmers (however, some compilers will point out the problem to you, which
is helpful).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A similar problem is using bitwise
<I>and</I> and <I>or</I> instead of their logical counterparts. Bitwise
<I>and</I> and <I>or</I> use one of the characters (<B>&amp;</B> or <B>|</B>),
while logical <I>and</I> and <I>or</I> use two (<B>&amp;&amp;</B> and
<B>||</B>). Just as with <B>=</B> and <B>==</B>, it&#8217;s easy to just type
one character instead of two. A useful mnemonic device is to observe that
&#8220;Bits are smaller, so they don&#8217;t need as many characters in their
operators.&#8221;<A NAME="Index799"></A><A NAME="Index800"></A><A NAME="Index801"></A><A NAME="Index802"></A><A NAME="Index803"></A><A NAME="Index804"></A><A NAME="Index805"></A></FONT><A NAME="_Toc462979781"></A><A NAME="_Toc472654787"></A><BR></P></DIV>
<A NAME="Heading149"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Casting operators<A NAME="Index806"></A><A NAME="Index807"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The word <I>cast</I> is used in the sense
of &#8220;casting into a mold.&#8221; The compiler will automatically change one
type of data into another if it makes sense. For instance, if you assign an
integral value to a floating-point variable, the compiler will secretly call a
function (or more probably, insert code) to convert the <B>int</B> to a
<B>float</B>. Casting allows you to make this type conversion explicit, or to
force it when it wouldn&#8217;t normally happen.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To perform a cast, put the desired data
type (including all modifiers) inside parentheses to the left of the value. This
value can be a variable, a constant, the value produced by an expression, or the
return value of a function. Here&#8217;s an example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:SimpleCast.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> b = 200;
  <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> a = (<font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> <font color=#0000ff>int</font>)b;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Casting is powerful, but it can cause
headaches because in some situations it forces the compiler to treat data as if
it were (for instance) larger than it really is, so it will occupy more space in
memory; this can trample over other data. This usually occurs when casting
pointers, not when making simple casts like the one shown
above.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C++ has an additional casting syntax,
which follows the function call syntax. This syntax puts the parentheses around
the argument, like a function call, rather than around the data
type:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:FunctionCallCast.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>float</font> a = <font color=#0000ff>float</font>(200);
  <font color=#009900>// This is equivalent to:</font>
  <font color=#0000ff>float</font> b = (<font color=#0000ff>float</font>)200;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Of course in the case above you
wouldn&#8217;t really need a cast; you could just say <B>200f</B> (in effect,
that&#8217;s typically what the compiler will do for the above expression).
Casts are generally used instead with variables, rather than
constants.</FONT><A NAME="_Toc462979782"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index808"></A><A NAME="Index809"></A><A NAME="Index810"></A><A NAME="_Toc472654788"></A><BR></P></DIV>
<A NAME="Heading150"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
C++ explicit casts</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Casts should be used carefully, because
what you are actually doing is saying to the compiler &#8220;Forget
<A NAME="Index811"></A>type checking &#8211; treat it as this other type
instead.&#8221; That is, you&#8217;re introducing a hole in the C++ type system
and preventing the compiler from telling you that you&#8217;re doing something
wrong with a type. What&#8217;s worse, the compiler believes you implicitly and
doesn&#8217;t perform any other checking to catch errors. Once you start
casting, you open yourself up for all kinds of problems. In fact, any program
that uses a lot of casts should be viewed with suspicion, no matter how much you
are told it simply &#8220;must&#8221; be done that way. In general, casts should
be few and isolated to the solution of very specific problems.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you understand this and are
presented with a <A NAME="Index812"></A>buggy program, your first inclination
may be to look for casts as culprits. But how do you locate C-style casts? They
are simply type names inside of parentheses, and if you start hunting for such
things you&#8217;ll discover that it&#8217;s often hard to distinguish them from
the rest of your code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Standard C++ includes an explicit cast
syntax that can be used to completely replace the old C-style casts (of course,
C-style casts cannot be outlawed without breaking code, but compiler writers
could easily flag old-style casts for you). The explicit cast syntax is such
that you can easily find them, as you can see by their names:</FONT><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TD WIDTH=114 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>static_cast</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=199 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For &#8220;well-behaved&#8221; and
&#8220;reasonably well-behaved&#8221; casts, including things you might now do
without a cast (such as an automatic type conversion).</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=114 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>const_cast</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=199 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To cast away <B>const</B> and/or
<B>volatile</B>.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=114 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>reinterpret_cast</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=199 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To cast to a completely different
meaning. The key is that you&#8217;ll need to cast back to the original type to
use it safely. The type you cast to is typically used only for bit twiddling or
some other mysterious purpose. This is the most dangerous of all the
casts.</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=114 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>dynamic_cast</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=199 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For type-safe downcasting (this cast will
be described in Chapter 15).</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>
<DIV ALIGN="LEFT"><P><BR><FONT FACE="Georgia">The first three explicit casts will
be described more completely in the following sections, while the last one can
be demonstrated only after you&#8217;ve learned more, in Chapter
15.</FONT><A NAME="_Toc312374151"></A><A NAME="_Toc461661973"></A><BR></P></DIV>
<A NAME="Heading151"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
static_cast<BR><A NAME="Index813"></A><A NAME="Index814"></A><A NAME="Index815"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>static_cast</B> is used for all
conversions that are well-defined. These include &#8220;safe&#8221; conversions
that the compiler would allow you to do without a cast and less-safe conversions
that are nonetheless well-defined. The types of conversions covered by
<B>static_cast</B> include typical castless conversions, narrowing
(information-losing) conversions, forcing a conversion from a <B>void*</B>,
implicit type conversions, and static navigation of class hierarchies (since you
haven&#8217;t seen classes and inheritance yet, this last topic will be delayed
until Chapter 15):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:static_cast.cpp</font>
<font color=#0000ff>void</font> func(<font color=#0000ff>int</font>) {}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i = 0x7fff; <font color=#009900>// Max pos value = 32767</font>
  <font color=#0000ff>long</font> l;
  <font color=#0000ff>float</font> f;
  <font color=#009900>// (1) Typical castless conversions:</font>
  l = i;
  f = i;
  <font color=#009900>// Also works:</font>
  l = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>long</font>&gt;(i);
  f = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>float</font>&gt;(i);

  <font color=#009900>// (2) Narrowing conversions:</font>
  i = l; <font color=#009900>// May lose digits</font>
  i = f; <font color=#009900>// May lose info</font>
  <font color=#009900>// Says "I know," eliminates warnings:</font>
  i = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>int</font>&gt;(l);
  i = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>int</font>&gt;(f);
  <font color=#0000ff>char</font> c = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>char</font>&gt;(i);

  <font color=#009900>// (3) Forcing a conversion from void* :</font>
  <font color=#0000ff>void</font>* vp = &amp;i;
  <font color=#009900>// Old way produces a dangerous conversion:</font>
  <font color=#0000ff>float</font>* fp = (<font color=#0000ff>float</font>*)vp;
  <font color=#009900>// The new way is equally dangerous:</font>
  fp = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>float</font>*&gt;(vp);

  <font color=#009900>// (4) Implicit type conversions, normally</font>
  <font color=#009900>// performed by the compiler:</font>
  <font color=#0000ff>double</font> d = 0.0;
  <font color=#0000ff>int</font> x = d; <font color=#009900>// Automatic type conversion</font>
  x = <font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>int</font>&gt;(d); <font color=#009900>// More explicit</font>
  func(d); <font color=#009900>// Automatic type conversion</font>
  func(<font color=#0000ff>static_cast</font>&lt;<font color=#0000ff>int</font>&gt;(d)); <font color=#009900>// More explicit</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In Section (1), you see the kinds of
conversions you&#8217;re used to doing in C, with or without a cast. Promoting
from an <B>int</B> to a <B>long</B> or <B>float</B> is not a problem because the
latter can always hold every value that an <B>int</B> can contain. Although
it&#8217;s unnecessary, you can use <B>static_cast</B> to highlight these
promotions.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Converting back the other way is shown in
(2). Here, you can lose data because an <B>int</B> is not as &#8220;wide&#8221;
as a <B>long</B> or a <B>float</B>; it won&#8217;t hold numbers of the same
size. Thus these are called <I>narrowing
conversions<A NAME="Index816"></A><A NAME="Index817"></A></I>. The compiler will
still perform these, but will often give you a warning. You can eliminate this
warning and indicate that you really did mean it using a cast.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Assigning from a
<A NAME="Index818"></A><B>void*</B> is not allowed without a cast in C++ (unlike
C), as seen in (3). This is dangerous and requires that programmers know what
they&#8217;re doing. The <B>static_cast</B>, at least, is easier to locate than
the old standard cast when you&#8217;re hunting for bugs.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Section (4) of the program shows the
kinds of implicit type conversions that are normally performed automatically by
the compiler. These are automatic and require no casting, but again
<B>static_cast</B> highlights the action in case you want to make it clear
what&#8217;s happening or hunt for it
later.</FONT><A NAME="_Toc312374152"></A><A NAME="_Toc461661974"></A><BR></P></DIV>
<A NAME="Heading152"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
const_cast<BR><A NAME="Index819"></A><A NAME="Index820"></A><A NAME="Index821"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you want to convert from a
<B>const</B> to a non<B>const</B> or from a
<A NAME="Index822"></A><B>volatile</B> to a non<B>volatile</B>, you use
<B>const_cast</B>. This is the <I>only</I> conversion allowed with
<B>const_cast</B>; if any other conversion is involved it must be done using a
separate expression or you&#8217;ll get a compile-time error.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:const_cast.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>const</font> <font color=#0000ff>int</font> i = 0;
  <font color=#0000ff>int</font>* j = (<font color=#0000ff>int</font>*)&amp;i; <font color=#009900>// Deprecated form</font>
  j  = <font color=#0000ff>const_cast</font>&lt;<font color=#0000ff>int</font>*&gt;(&amp;i); <font color=#009900>// Preferred</font>
  <font color=#009900>// Can't do simultaneous additional casting:</font>
<font color=#009900>//! long* l = const_cast&lt;long*&gt;(&amp;i); // Error</font>
  <font color=#0000ff>volatile</font> <font color=#0000ff>int</font> k = 0;
  <font color=#0000ff>int</font>* u = <font color=#0000ff>const_cast</font>&lt;<font color=#0000ff>int</font>*&gt;(&amp;k);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you take the address of a <B>const</B>
object, you produce a <A NAME="Index823"></A><A NAME="Index824"></A>pointer to a
<B>const</B>, and this cannot be assigned to a non<B>const</B> pointer without a
cast. The old-style cast will accomplish this, but the <B>const_cast</B> is the
appropriate one to use. The same holds true for
<B>volatile</B>.</FONT><A NAME="_Toc312374153"></A><A NAME="_Toc461661975"></A><BR></P></DIV>
<A NAME="Heading153"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
reinterpret_cast<BR><A NAME="Index825"></A><A NAME="Index826"></A><A NAME="Index827"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is the least safe of the casting
mechanisms, and the one most likely to produce bugs. A <B>reinterpret_cast</B>
pretends that an object is just a bit pattern that can be treated (for some dark
purpose) as if it were an entirely different type of object. This is the
low-level bit twiddling that C is notorious for. You&#8217;ll virtually always
need to <B>reinterpret_cast</B> back to the original type (or otherwise treat
the variable as its original type) before doing anything else with
it.</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:reinterpret_cast.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>const</font> <font color=#0000ff>int</font> sz = 100;

<font color=#0000ff>struct</font> X { <font color=#0000ff>int</font> a[sz]; };

<font color=#0000ff>void</font> print(X* x) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; sz; i++)
    cout &lt;&lt; x-&gt;a[i] &lt;&lt; ' ';
  cout &lt;&lt; endl &lt;&lt; <font color=#004488>"--------------------"</font> &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  X x;
  print(&amp;x);
  <font color=#0000ff>int</font>* xp = <font color=#0000ff>reinterpret_cast</font>&lt;<font color=#0000ff>int</font>*&gt;(&amp;x);
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font>* i = xp; i &lt; xp + sz; i++)
    *i = 0;
  <font color=#009900>// Can't use xp as an X* at this point</font>
  <font color=#009900>// unless you cast it back:</font>
  print(<font color=#0000ff>reinterpret_cast</font>&lt;X*&gt;(xp));
  <font color=#009900>// In this example, you can also just use</font>
  <font color=#009900>// the original identifier:</font>
  print(&amp;x);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this simple example, <B>struct X</B>
just contains an array of <B>int</B>, but when you create one on the stack as in
<B>X x</B>, the values of each of the <B>int</B>s are garbage (this is shown
using the <B>print(&#160;)</B> function to display the contents of the
<B>struct</B>). To initialize them, the address of the <B>X</B> is taken and
cast to an <B>int</B> pointer, which is then walked through the array to set
each <B>int</B> to zero. Notice how the upper bound for <B>i</B> is calculated
by &#8220;adding&#8221; <B>sz</B> to <B>xp</B>; the compiler knows that you
actually want <B>sz</B> pointer locations greater than <B>xp</B> and it does the
correct pointer arithmetic for you.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The idea of <B>reinterpret_cast</B> is
that when you use it, what you get is so foreign that it cannot be used for the
type&#8217;s original purpose unless you cast it back. Here, we see the cast
back to an <B>X*</B> in the call to print, but of course since you still have
the original identifier you can also use that. But the <B>xp</B> is only useful
as an <B>int*</B>, which is truly a &#8220;reinterpretation&#8221; of the
original <B>X</B>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>reinterpret_cast</B> often indicates
inadvisable and/or nonportable programming, but it&#8217;s available when you
decide you have to use
it.</FONT><A NAME="_Toc462979783"></A><A NAME="_Toc472654789"></A><BR></P></DIV>
<A NAME="Heading154"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
sizeof &#8211; an operator by itself
<A NAME="Index828"></A><A NAME="Index829"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <A NAME="Index830"></A><B>sizeof</B>
operator stands alone because it satisfies an unusual need. <B>sizeof</B> gives
you information about the amount of memory allocated for data items. As
described earlier in this chapter, <B>sizeof</B> tells you the number of bytes
used by any particular variable. It can also give the size of a data type (with
no variable name):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:sizeof.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#0000ff>int</font> main() {
  cout &lt;&lt; <font color=#004488>"sizeof(double) = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(<font color=#0000ff>double</font>);
  cout &lt;&lt; <font color=#004488>", sizeof(char) = "</font> &lt;&lt; <font color=#0000ff>sizeof</font>(<font color=#0000ff>char</font>);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By definition, the
<A NAME="Index831"></A><A NAME="Index832"></A><B>sizeof</B> any type of
<B>char</B> (<B>signed</B>, <B>unsigned</B> or plain) is always one, regardless
of whether the underlying storage for a <B>char</B> is actually one byte. For
all other types, the result is the size in bytes.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note that <B>sizeof</B> is an operator,
not a function. If you apply it to a type, it must be used with the
parenthesized form shown above, but if you apply it to a variable you can use it
without parentheses:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:sizeofOperator.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> x;
  <font color=#0000ff>int</font> i = <font color=#0000ff>sizeof</font> x;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>sizeof</B> can also give you the sizes
of user-defined data types. This is used later in the
book.</FONT><A NAME="_Toc312374161"></A><A NAME="_Toc462979784"></A><A NAME="_Toc472654790"></A><BR></P></DIV>
<A NAME="Heading155"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The asm keyword<BR><A NAME="Index833"></A><A NAME="Index834"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This is an escape mechanism that allows
you to write assembly code for your hardware within a C++ program. Often
you&#8217;re able to reference C++ variables within the assembly code, which
means you can easily communicate with your C++ code and limit the assembly code
to that necessary for efficiency tuning or to use special processor
instructions. The exact syntax that you must use when writing the assembly
language is compiler-dependent and can be discovered in your compiler&#8217;s
documentation.</FONT><A NAME="_Toc312374162"></A><A NAME="_Toc462979785"></A><A NAME="_Toc472654791"></A><BR></P></DIV>
<A NAME="Heading156"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Explicit operators</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">These are keywords for bitwise and
logical
operators<A NAME="Index835"></A><A NAME="Index836"></A><A NAME="Index837"></A>.
Non-U.S. programmers without keyboard characters like <B>&amp;</B>, <B>|</B>,
<B>^</B>, and so on, were forced to use C&#8217;s horrible <I>trigraphs</I>,
which were not only annoying to type, but obscure when reading. This is repaired
in C++ with additional
keywords:<A NAME="Index838"></A><A NAME="Index839"></A><A NAME="Index840"></A><A NAME="Index841"></A><A NAME="Index842"></A><A NAME="Index843"></A><A NAME="Index844"></A><A NAME="Index845"></A><A NAME="Index846"></A><A NAME="Index847"></A><A NAME="Index848"></A></FONT><BR><BR></P></DIV>
<DIV ALIGN="CENTER"><TABLE BORDER>
<TR VALIGN="TOP">
<TH WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>Keyword</B></FONT><BR></P></DIV>
</TH>
<TH WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B>Meaning</B></FONT><BR></P></DIV>
</TH>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>and</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&amp;&amp;</B> (logical
<I>and</I>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>or</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>|| </B>(logical
<I>or</I>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>not</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>!</B> (logical NOT)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B> not_eq</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>!=</B> (logical
not-equivalent)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bitand</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&amp;</B> (bitwise
<I>and</I>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>and_eq</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>&amp;=</B> (bitwise
<I>and</I>-assignment)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>bitor</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>|</B> (bitwise
<I>or</I>)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>or_eq</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>|=</B> (bitwise or-assignment)
</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>xor</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>^</B> (bitwise
exclusive-or)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>xor_eq</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>^=</B> (bitwise
exclusive-or-assignment)</FONT><BR></P></DIV>
</TD>
</TR>
<TR VALIGN="TOP">
<TD WIDTH=87 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>compl</B></FONT><BR></P></DIV>
</TD>
<TD WIDTH=180 COLSPAN=1 ROWSPAN=1 VALIGN="TOP">
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>~</B> (ones
complement)</FONT><BR></P></DIV>
</TD>
</TR>
</TABLE></P></DIV>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If your compiler complies with Standard
C++, it will support these
keywords.</FONT><A NAME="_Toc462979786"></A><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index849"></A><A NAME="Index850"></A><A NAME="_Toc472654792"></A><BR></P></DIV>
<A NAME="Heading157"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Composite type creation</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fundamental data types and their
variations are essential, but rather primitive. C and C++ provide tools that
allow you to compose more sophisticated data types from the fundamental data
types. As you&#8217;ll see, the most important of these is <B>struct</B>, which
is the foundation for <B>class</B> in C++. However, the simplest way to create
more sophisticated types is simply to alias a name to another name via
<B>typedef</B>.</FONT><A NAME="_Toc462979787"></A><A NAME="_Toc472654793"></A><BR></P></DIV>
<A NAME="Heading158"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Aliasing names with typedef</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This keyword promises more than it
delivers: <A NAME="Index851"></A><A NAME="Index852"></A><B>typedef </B>suggests
&#8220;type definition&#8221; when &#8220;alias&#8221; would probably have been
a more accurate description, since that&#8217;s what it really does. The syntax
is:</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>typedef existing-type-description
alias-name</B></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">People often use <B>typedef</B> when data
types get slightly complicated, just to prevent extra keystrokes. Here is a
commonly-used <B>typedef</B>:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> <font color=#0000ff>unsigned</font> <font color=#0000ff>long</font> ulong; </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Now if you say <B>ulong</B> the compiler
knows that you mean <B>unsigned long</B>. You might think that this could as
easily be accomplished using preprocessor substitution, but there are key
situations in which the compiler must be aware that you&#8217;re treating a name
as if it were a type, so <B>typedef</B> is essential.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One place where <B>typedef</B> comes in
handy is for pointer types. As previously mentioned, if you
say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font>* x, y;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This actually produces an <B>int*</B>
which is <B>x</B> and an <B>int</B> (not an <B>int*</B>)<B> </B>which is
<B>y</B>. That is, the &#8216;<B>*</B>&#8217; binds to the right, not the left.
However, if you use a <B>typedef</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>typedef</font> <font color=#0000ff>int</font>* IntPtr;
IntPtr x, y;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Then both <B>x </B>and <B>y</B> are of
type <B>int*</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can argue that it&#8217;s more
explicit and therefore more readable to avoid <B>typedef</B>s for primitive
types, and indeed programs rapidly become difficult to read when many
<B>typedef</B>s are used. However, <B>typedef</B>s become especially important
in C when used with
<B>struct</B>.</FONT><A NAME="_Toc462979788"></A><A NAME="_Toc472654794"></A><BR></P></DIV>
<A NAME="Heading159"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Combining variables with struct</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A
<A NAME="Index853"></A><A NAME="Index854"></A><B>struct</B> is a way to collect
a group of variables into a structure. Once you create a <B>struct</B>, then you
can make many instances of this &#8220;new&#8221; type of variable you&#8217;ve
invented.  For example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:SimpleStruct.cpp</font>
<font color=#0000ff>struct</font> Structure1 {
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
};

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>struct</font> Structure1 s1, s2;
  s1.c = 'a'; <font color=#009900>// Select an element using a '.'</font>
  s1.i = 1;
  s1.f = 3.14;
  s1.d = 0.00093;
  s2.c = 'a';
  s2.i = 1;
  s2.f = 3.14;
  s2.d = 0.00093;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>struct</B> declaration must end
with a semicolon. In <B>main(&#160;)</B>, two instances of <B>Structure1</B> are
created: <B>s1</B> and <B>s2</B>. Each of these has their own separate versions
of <B>c</B>, <B>i</B>, <B>f</B>, and <B>d</B>. So <B>s1</B> and <B>s2</B>
represent clumps of completely independent variables. To select one of the
elements within <B>s1</B> or <B>s2</B>, you use a &#8216;<B>.</B>&#8217;, syntax
you&#8217;ve seen in the previous chapter when using C++ <B>class </B>objects
&#8211; since <B>class</B>es evolved from <B>struct</B>s, this is where that
syntax arose from.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One thing you&#8217;ll notice is the
awkwardness of the use of <B>Structure1</B> (as it turns out, this is only
required by C, not C++). In C, you can&#8217;t just say <B>Structure1</B> when
you&#8217;re defining variables, you must say <B>struct Structure1</B>. This is
where <B>typedef</B> becomes especially handy in C:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:SimpleStruct2.cpp</font>
<font color=#009900>// Using typedef with struct</font>
<font color=#0000ff>typedef</font> <font color=#0000ff>struct</font> {
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
} Structure2;

<font color=#0000ff>int</font> main() {
  Structure2 s1, s2;
  s1.c = 'a';
  s1.i = 1;
  s1.f = 3.14;
  s1.d = 0.00093;
  s2.c = 'a';
  s2.i = 1;
  s2.f = 3.14;
  s2.d = 0.00093;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By using
<A NAME="Index855"></A><B>typedef</B> in this way, you can pretend (in C; try
removing the <B>typedef </B>for C++) that <B>Structure2</B> is a built-in type,
like <B>int</B> or <B>float</B>, when you define <B>s1</B> and <B>s2</B> (but
notice it only has data &#8211; characteristics &#8211; and does not include
behavior, which is what we get with real objects in C++). You&#8217;ll notice
that the <B>struct</B> identifier has been left off at the beginning, because
the goal is to create the <B>typedef</B>. However, there are times when you
might need to refer to the <B>struct</B> during its definition. In those cases,
you can actually repeat the name of the <B>struct</B> as the <B>struct</B> name
and as the <B>typedef</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:SelfReferential.cpp</font>
<font color=#009900>// Allowing a struct to refer to itself</font>

<font color=#0000ff>typedef</font> <font color=#0000ff>struct</font> SelfReferential {
  <font color=#0000ff>int</font> i;
  SelfReferential* sr; <font color=#009900>// Head spinning yet?</font>
} SelfReferential;

<font color=#0000ff>int</font> main() {
  SelfReferential sr1, sr2;
  sr1.sr = &amp;sr2;
  sr2.sr = &amp;sr1;
  sr1.i = 47;
  sr2.i = 1024;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you look at this for awhile,
you&#8217;ll see that <B>sr1</B> and <B>sr2</B> point to each other, as well as
each holding a piece of data. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Actually, the <B>struct</B> name does not
have to be the same as the <B>typedef</B> name, but it is usually done this way
as it tends to keep things simpler.</FONT><BR></P></DIV>
<A NAME="Heading160"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Pointers and
structs<BR><A NAME="Index856"></A><A NAME="Index857"></A><A NAME="Index858"></A><A NAME="Index859"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the examples above, all the
<B>struct</B>s are manipulated as objects. However, like any piece of storage,
you can take the <A NAME="Index860"></A>address of a <B>struct</B> object (as
seen in <B>SelfReferential.cpp</B> above). To select the elements of a
particular <B>struct</B> object, you use a &#8216;<B>.</B>&#8217;, as seen
above. However, if you have a pointer to a <B>struct </B>object, you must select
an element of that object using a different operator: the
&#8216;<B>-&gt;</B>&#8217;. Here&#8217;s an example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:SimpleStruct3.cpp</font>
<font color=#009900>// Using pointers to structs</font>
<font color=#0000ff>typedef</font> <font color=#0000ff>struct</font> Structure3 {
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
} Structure3;

<font color=#0000ff>int</font> main() {
  Structure3 s1, s2;
  Structure3* sp = &amp;s1;
  sp-&gt;c = 'a';
  sp-&gt;i = 1;
  sp-&gt;f = 3.14;
  sp-&gt;d = 0.00093;
  sp = &amp;s2; <font color=#009900>// Point to a different struct object</font>
  sp-&gt;c = 'a';
  sp-&gt;i = 1;
  sp-&gt;f = 3.14;
  sp-&gt;d = 0.00093;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In <B>main(&#160;)</B>, the <B>struct</B>
pointer <B>sp</B> is initially pointing to <B>s1</B>, and the members of
<B>s1</B> are initialized by selecting them with the &#8216;<B>-&gt;</B>&#8217;
(and you use this same operator in order to read those members). But then
<B>sp</B> is pointed to <B>s2</B>, and those variables are initialized the same
way. So you can see that another benefit of pointers is that they can be
dynamically redirected to point to different objects; this provides more
flexibility in your programming, as you will learn.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For now, that&#8217;s all you need to
know about <B>struct</B>s, but<B> </B>you&#8217;ll become much more comfortable
with them (and especially their more potent successors, <B>class</B>es) as the
book
progresses.</FONT><A NAME="_Toc462979789"></A><A NAME="_Toc472654795"></A><BR></P></DIV>
<A NAME="Heading161"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Clarifying programs with enum<A NAME="Index861"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An enumerated data type is a way of
attaching names to numbers, thereby giving more meaning to anyone reading the
code. The <A NAME="Index862"></A><A NAME="Index863"></A><B>enum</B> keyword
(from C) automatically enumerates any list of identifiers you give it by
assigning them values of 0, 1, 2, etc. You can declare <B>enum</B> variables
(which are always represented as integral values). The declaration of an
<B>enum</B> looks similar to a <B>struct</B> declaration.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">An enumerated data type is useful when
you want to keep track of some sort of feature:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Enum.cpp</font>
<font color=#009900>// Keeping track of shapes</font>

<font color=#0000ff>enum</font> ShapeType {
  circle,
  square,
  rectangle
};  <font color=#009900>// Must end with a semicolon like a struct</font>

<font color=#0000ff>int</font> main() {
  ShapeType shape = circle;
  <font color=#009900>// Activities here....</font>
  <font color=#009900>// Now do something based on what the shape is:</font>
  <font color=#0000ff>switch</font>(shape) {
    <font color=#0000ff>case</font> circle:  <font color=#009900>/* circle stuff */</font> <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> square:  <font color=#009900>/* square stuff */</font> <font color=#0000ff>break</font>;
    <font color=#0000ff>case</font> rectangle:  <font color=#009900>/* rectangle stuff */</font> <font color=#0000ff>break</font>;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><B>shape</B> is a variable of the
<B>ShapeType</B> enumerated data type, and its value is compared with the value
in the enumeration. Since <B>shape</B> is really just an <B>int</B>, however, it
can be any value an <B>int</B> can hold (including a negative number). You can
also compare an <B>int</B> variable with a value in the
enumeration.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You should be aware that the example
above of switching on type turns out to be a problematic way to program. C++ has
a much better way to code this sort of thing, the explanation of which must be
delayed until much later in the book.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you don&#8217;t like the way the
compiler assigns values, you can do it yourself, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>enum</font> ShapeType { 
  circle = 10, square = 20, rectangle = 50
}; </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you give values to some names and not
to others, the compiler will use the next integral value. For
example,</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>enum</font> snap { crackle = 25, pop };</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The compiler gives <B>pop</B> the value
26.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see how much more readable the
code is when you use enumerated data types. However, to some degree this is
still an attempt (in C) to accomplish the things that we can do with a
<B>class</B> in C++, so you&#8217;ll see <B>enum</B> used less in
C++.</FONT><BR></P></DIV>
<A NAME="Heading162"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Type checking for enumerations</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C&#8217;s enumerations
<A NAME="Index864"></A><A NAME="Index865"></A>are fairly primitive, simply
associating integral values with names, but they provide no type checking. In
C++, as you may have come to expect by now, the concept of type is fundamental,
and this is true with enumerations. When you create a named enumeration, you
effectively create a new type just as you do with a class: The name of your
enumeration becomes a reserved word for the duration of that translation unit.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In addition, there&#8217;s stricter type
checking for enumerations in C++ than in C. You&#8217;ll notice this in
particular if you have an instance of an enumeration
<A NAME="Index866"></A><A NAME="Index867"></A><B>color</B> called <B>a</B>. In C
you can say <B>a++,</B> but in C++ you can&#8217;t. This is because incrementing
an enumeration is performing two type conversions, one of them legal in C++ and
one of them illegal. First, the value of the enumeration is implicitly cast from
a <B>color</B> to an <B>int</B>, then the value is incremented, then the
<B>int</B> is cast back into a <B>color</B>. In C++ this isn&#8217;t allowed,
because <B>color</B> is a distinct type and not equivalent to an <B>int</B>.
This makes sense, because how do you know the increment of <B>blue</B> will even
be in the list of colors? If you want to increment a <B>color</B>, then it
should be a class (with an increment operation) and not an <B>enum</B>, because
the class can be made to be much safer. Any time you write code that assumes an
implicit conversion to an <B>enum</B> type, the compiler will flag this
inherently dangerous activity.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Unions (described next)
<A NAME="Index868"></A><A NAME="Index869"></A>have similar additional type
checking in
C++.</FONT><A NAME="_Toc462979790"></A><A NAME="_Toc472654796"></A><BR></P></DIV>
<A NAME="Heading163"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Saving memory with union <A NAME="Index870"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Sometimes a program will handle different
types of data using the same variable. In this situation, you have two choices:
you can create a <B>struct</B> containing all the possible different types you
might need to store, or you can use a <A NAME="Index871"></A><B>union</B>. A
<B>union</B> piles all the data into a single space; it figures out the amount
of space necessary for the largest item you&#8217;ve put in the <B>union</B>,
and makes that the size of the <B>union</B>. Use a <B>union</B> to save
memory.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Anytime you place a value in a
<B>union</B>, the value always starts in the same place at the beginning of the
<B>union</B>, but only uses as much space as is necessary. Thus, you create a
&#8220;super-variable&#8221; capable of holding any of the <B>union</B>
variables. All the addresses of the <B>union</B> variables are the same (in a
class or <B>struct</B>, the addresses are different).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here&#8217;s a simple use of a
<B>union</B>. Try removing various elements and see what effect it has on the
size of the <B>union</B>. Notice that it makes no sense to declare more than one
instance of a single data type in a <B>union</B> (unless you&#8217;re just doing
it to use a different name).</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Union.cpp</font>
<font color=#009900>// The size and simple use of a union</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>union</font> Packed { <font color=#009900>// Declaration similar to a class</font>
  <font color=#0000ff>char</font> i;
  <font color=#0000ff>short</font> j;
  <font color=#0000ff>int</font> k;
  <font color=#0000ff>long</font> l;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;  
  <font color=#009900>// The union will be the size of a </font>
  <font color=#009900>// double, since that's the largest element</font>
};  <font color=#009900>// Semicolon ends a union, like a struct</font>

<font color=#0000ff>int</font> main() {
  cout &lt;&lt; <font color=#004488>"sizeof(Packed) = "</font> 
       &lt;&lt; <font color=#0000ff>sizeof</font>(Packed) &lt;&lt; endl;
  Packed x;
  x.i = 'c';
  cout &lt;&lt; x.i &lt;&lt; endl;
  x.d = 3.14159;
  cout &lt;&lt; x.d &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The compiler performs the proper
assignment according to the union member you select.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you perform an assignment, the
compiler doesn&#8217;t care what you do with the union. In the example above,
you could assign a floating-point value to <B>x</B>:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>x.f = 2.222;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">and then send it to the output as if it
were an <B>int</B>:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cout &lt;&lt; x.i;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This would produce
garbage.</FONT><A NAME="_Toc462979791"></A><A NAME="_Toc472654797"></A><BR></P></DIV>
<A NAME="Heading164"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Arrays<BR><A NAME="Index872"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Arrays are a kind of
<A NAME="Index873"></A>composite type because they allow you to clump a lot of
variables together, one right after the other, under a single identifier name.
If you say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> a[10];</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You create storage for 10 <B>int</B>
variables stacked on top of each other, but without unique identifier names for
each variable. Instead, they are all lumped under the name
<B>a</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To access one of these <I>array
elements</I>, you use the same square-bracket syntax that you use to define an
<A NAME="Index874"></A>array:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>a[5] = 47;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">However, you must remember that even
though the <I>size</I> of <B>a</B> is 10, you select array elements starting at
zero (this is sometimes called
<A NAME="Index875"></A><A NAME="Index876"></A><I>zero indexing</I>), so you can
select only the array elements 0-9, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Arrays.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[10];
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++) {
    a[i] = i * 10;
    cout &lt;&lt; <font color=#004488>"a["</font> &lt;&lt; i &lt;&lt; <font color=#004488>"] = "</font> &lt;&lt; a[i] &lt;&lt; endl;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Array access is extremely fast. However,
if you index past the end of the array, there is no safety net &#8211;
you&#8217;ll step on other variables. The other drawback is that you must define
the size of the array at compile time; if you want to change the size at runtime
you can&#8217;t do it with the syntax above (C does have a way to create an
array dynamically, but it&#8217;s significantly messier). The C++ <B>vector</B>,
introduced in the previous chapter, provides an array-like object that
automatically resizes itself, so it is usually a much better solution if your
array size cannot be known at compile time.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can make an array of any type, even
of <A NAME="Index877"></A><B>struct</B>s:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:StructArray.cpp</font>
<font color=#009900>// An array of struct</font>

<font color=#0000ff>typedef</font> <font color=#0000ff>struct</font> {
  <font color=#0000ff>int</font> i, j, k;
} ThreeDpoint;

<font color=#0000ff>int</font> main() {
  ThreeDpoint p[10];
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++) {
    p[i].i = i + 1;
    p[i].j = i + 2;
    p[i].k = i + 3;
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Notice how the <B>struct</B> identifier
<B>i</B> is independent of the <B>for</B> loop&#8217;s
<B>i</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To see that each element of an array is
contiguous with the next, you can print out the addresses like
this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:ArrayAddresses.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[10];
  cout &lt;&lt; <font color=#004488>"sizeof(int) = "</font>&lt;&lt; <font color=#0000ff>sizeof</font>(<font color=#0000ff>int</font>) &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
    cout &lt;&lt; <font color=#004488>"&amp;a["</font> &lt;&lt; i &lt;&lt; <font color=#004488>"] = "</font> 
         &lt;&lt; (<font color=#0000ff>long</font>)&amp;a[i] &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program, you&#8217;ll
see that each element is one <B>int</B> size away from the previous one. That
is, they are stacked one on top of the other.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index878"></A><A NAME="Index879"></A><BR></P></DIV>
<A NAME="Heading165"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Pointers and arrays</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The identifier of an array is unlike the
identifiers for ordinary variables. For one thing, an array identifier is not an
lvalue; you cannot assign to it. It&#8217;s really just a hook into the
square-bracket syntax, and when you give the name of an array, without square
brackets, what you get is the starting address of the array:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:ArrayIdentifier.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[10];
  cout &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; a &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"&amp;a[0] ="</font> &lt;&lt; &amp;a[0] &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you run this program you&#8217;ll
see that the two addresses (which will be printed in hexadecimal, since there is
no cast to <B>long</B>) are the same.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So one way to look at the array
identifier is as a read-only pointer to the beginning of an array. And although
we can&#8217;t change the array identifier to point somewhere else, we
<I>can</I> create another pointer and use that to move around in the array. In
fact, the square-bracket syntax works with regular
<A NAME="Index880"></A>pointers as well:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PointersAndBrackets.cpp</font>
<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[10];
  <font color=#0000ff>int</font>* ip = a;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
    ip[i] = i * 10;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The fact that naming an array produces
its starting address turns out to be quite important when you want to pass an
array to a function. If you declare an array as a function argument, what
you&#8217;re really declaring is a pointer. So in the following example,
<B>func1(&#160;)</B> and <B>func2(&#160;)</B> effectively have the same argument
lists:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:ArrayArguments.cpp</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> func1(<font color=#0000ff>int</font> a[], <font color=#0000ff>int</font> size) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
    a[i] = i * i - i;
}

<font color=#0000ff>void</font> func2(<font color=#0000ff>int</font>* a, <font color=#0000ff>int</font> size) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
    a[i] = i * i + i;
}

<font color=#0000ff>void</font> print(<font color=#0000ff>int</font> a[], string name, <font color=#0000ff>int</font> size) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; size; i++)
    cout &lt;&lt; name &lt;&lt; <font color=#004488>"["</font> &lt;&lt; i &lt;&lt; <font color=#004488>"] = "</font> 
         &lt;&lt; a[i] &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[5], b[5];
  <font color=#009900>// Probably garbage values:</font>
  print(a, <font color=#004488>"a"</font>, 5);
  print(b, <font color=#004488>"b"</font>, 5);
  <font color=#009900>// Initialize the arrays:</font>
  func1(a, 5);
  func1(b, 5);
  print(a, <font color=#004488>"a"</font>, 5);
  print(b, <font color=#004488>"b"</font>, 5);
  <font color=#009900>// Notice the arrays are always modified:</font>
  func2(a, 5);
  func2(b, 5);
  print(a, <font color=#004488>"a"</font>, 5);
  print(b, <font color=#004488>"b"</font>, 5);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Even though <B>func1(&#160;)</B> and
<B>func2(&#160;)</B> declare their arguments differently, the usage is the same
inside the function. There are some other issues that this example reveals:
arrays cannot be <A NAME="Index881"></A>passed by
value</FONT><A NAME="fnB32" HREF="#fn32">[32]</A><FONT FACE="Georgia">, that is,
you never automatically get a <A NAME="Index882"></A>local copy of the array
that you pass into a function. Thus, when you modify an array, you&#8217;re
always modifying the outside object. This can be a bit confusing at first, if
you&#8217;re expecting the pass-by-value provided with ordinary
arguments.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that
<B>print(&#160;)</B> uses the square-bracket syntax for array arguments. Even
though the pointer syntax and the square-bracket syntax are effectively the same
when passing arrays as arguments, the square-bracket syntax makes it clearer to
the reader that you mean for this argument to be an array.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Also note that the <B>size</B> argument
is passed in each case. Just passing the address of an array isn&#8217;t enough
information; you must always be able to know how big the array is inside your
function, so you don&#8217;t run off the end of that array.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Arrays can be of any type, including
<A NAME="Index883"></A><A NAME="Index884"></A>arrays of pointers. In fact, when
you want to pass command-line arguments into your program, C and C++ have a
special argument list for <B>main(&#160;)</B>, which looks like
this:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) { <font color=#009900>// ...</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The first argument is the number of
elements in the array, which is the second argument. The second argument is
always an array of <B>char*</B>, because the arguments are passed from the
command line as character arrays (and remember, an array can be passed only as a
pointer). Each whitespace-delimited cluster of characters on the command line is
turned into a separate array argument. The following program prints out all its
command-line arguments by stepping through the array:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:CommandLineArgs.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  cout &lt;&lt; <font color=#004488>"argc = "</font> &lt;&lt; argc &lt;&lt; endl;
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; argc; i++)
    cout &lt;&lt; <font color=#004488>"argv["</font> &lt;&lt; i &lt;&lt; <font color=#004488>"] = "</font> 
         &lt;&lt; argv[i] &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You&#8217;ll notice that <B>argv[0]</B>
is the path and name of the program itself. This allows the program to discover
information about itself. It also adds one more to the array of program
arguments, so a common error when fetching
<A NAME="Index885"></A><A NAME="Index886"></A>command-line arguments is to grab
<B>argv[0]</B> when you want <B>argv[1]</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You are not forced to use
<A NAME="Index887"></A><B>argc</B> and <A NAME="Index888"></A><B>argv</B> as
identifiers in <B>main(&#160;)</B>; those identifiers are only conventions (but
it will confuse people if you don&#8217;t use them). Also, there is an alternate
way to declare <B>argv</B>:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>** argv) { <font color=#009900>// ...</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Both forms are equivalent, but I find the
version used in this book to be the most intuitive when reading the code, since
it says, directly, &#8220;This is an array of character
pointers.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All you get from the command-line is
character arrays; if you want to treat an argument as some other type, you are
responsible for converting it inside your program. To facilitate the
<A NAME="Index889"></A><A NAME="Index890"></A>conversion to numbers, there are
some helper functions in the Standard C library, declared in
<A NAME="Index891"></A><A NAME="Index892"></A><B>&lt;cstdlib&gt;</B>. The
simplest ones to use are <A NAME="Index893"></A><B>atoi(&#160;)</B>,
<A NAME="Index894"></A><B>atol(&#160;),</B> and
<A NAME="Index895"></A><B>atof(&#160;)</B> to convert an ASCII character array
to an <B>int</B>, <B>long,</B> and <B>double</B> floating-point value,
respectively. Here&#8217;s an example using <B>atoi(&#160;)</B> (the other two
functions are called the same way):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:ArgsToInts.cpp</font>
<font color=#009900>// Converting command-line arguments to ints</font>
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 1; i &lt; argc; i++)
    cout &lt;&lt; atoi(argv[i]) &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In this program, you can put any number
of arguments on the command line. You&#8217;ll notice that the <B>for</B> loop
starts at the value <B>1</B> to skip over the program name at <B>argv[0]</B>.
Also, if you put a floating-point number containing a decimal point on the
command line, <B>atoi(&#160;)</B> takes only the digits up to the decimal point.
If you put non-numbers on the command line, these come back from
<B>atoi(&#160;)</B> as zero.</FONT><BR></P></DIV>
<A NAME="Heading166"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Exploring floating-point format</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>printBinary(&#160;)</B> function
introduced earlier in this chapter is handy for delving into the internal
structure of various data types. The most interesting of these is the
floating-point format that allows C and C++ to store numbers representing very
large and very small values in a limited amount of space. Although the details
can&#8217;t be completely exposed here, the bits inside of
<A NAME="Index896"></A><B>float</B>s and
<A NAME="Index897"></A><B>double</B>s<B> </B>are divided into three regions: the
exponent, the mantissa, and the sign bit; thus it stores the values using
scientific notation. The following program allows you to play around by printing
out the binary patterns of various floating point numbers so you can deduce for
yourself the scheme used in your compiler&#8217;s floating-point format (usually
this is the <A NAME="Index898"></A>IEEE standard for floating point numbers, but
your compiler may not follow that):</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:FloatingAsBinary.cpp</font>
<font color=#009900>//{L} printBinary</font>
<font color=#009900>//{T} 3.14159</font>
#include <font color=#004488>"printBinary.h"</font>
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>if</font>(argc != 2) {
    cout &lt;&lt; <font color=#004488>"Must provide a number"</font> &lt;&lt; endl;
    exit(1);
  }
  <font color=#0000ff>double</font> d = atof(argv[1]);
  <font color=#0000ff>unsigned</font> <font color=#0000ff>char</font>* cp = 
    <font color=#0000ff>reinterpret_cast</font>&lt;<font color=#0000ff>unsigned</font> <font color=#0000ff>char</font>*&gt;(&amp;d);
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = <font color=#0000ff>sizeof</font>(<font color=#0000ff>double</font>); i &gt; 0 ; i -= 2) {
    printBinary(cp[i-1]);
    printBinary(cp[i]);
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">First, the program guarantees that
you&#8217;ve given it an argument by checking the value of <B>argc</B>, which is
two if there&#8217;s a single argument (it&#8217;s one if there are no
arguments, since the program name is always the first element of <B>argv</B>).
If this fails, a message is printed and the Standard C Library function
<B>exit(&#160;)</B> is called to terminate the program.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The program grabs the argument from the
command line and converts the characters to a <B>double</B> using
<A NAME="Index899"></A><B>atof(&#160;)</B>. Then the double is treated as an
array of bytes by taking the address and casting it to an <B>unsigned char*</B>.
Each of these bytes is passed to <B>printBinary(&#160;)</B> for
display.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This example has been set up to print the
bytes in an order such that the sign bit appears first &#8211; on my machine.
Yours may be different, so you might want to re-arrange the way things are
printed. You should also be aware that floating-point formats are not trivial to
understand; for example, the exponent and mantissa are not generally arranged on
byte boundaries, but instead a number of bits is reserved for each one and they
are packed into the memory as tightly as possible. To truly see what&#8217;s
going on, you&#8217;d need to find out the size of each part of the number (sign
bits are always one bit, but exponents and mantissas are of differing sizes) and
print out the bits in each part separately.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index900"></A><A NAME="Index901"></A><BR></P></DIV>
<A NAME="Heading167"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Pointer arithmetic</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If all you could do with a pointer that
points at an array is treat it as if it were an alias for that array, pointers
into arrays wouldn&#8217;t be very interesting. However, pointers are more
flexible than this, since they can be modified to point somewhere else (but
remember, the array identifier cannot be modified to point somewhere
else).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia"><I>Pointer arithmetic</I> refers to the
application of some of the arithmetic operators to pointers. The reason pointer
arithmetic is a separate subject from ordinary arithmetic is that pointers must
conform to special constraints in order to make them behave properly. For
example, a common operator to use with pointers is
<A NAME="Index902"></A><B>++</B>, which &#8220;adds one to the pointer.&#8221;
What this actually means is that the pointer is changed to move to &#8220;the
next value,&#8221; whatever that means. Here&#8217;s an
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PointerIncrement.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i[10];
  <font color=#0000ff>double</font> d[10];
  <font color=#0000ff>int</font>* ip = i;
  <font color=#0000ff>double</font>* dp = d;
  cout &lt;&lt; <font color=#004488>"ip = "</font> &lt;&lt; (<font color=#0000ff>long</font>)ip &lt;&lt; endl;
  ip++;
  cout &lt;&lt; <font color=#004488>"ip = "</font> &lt;&lt; (<font color=#0000ff>long</font>)ip &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"dp = "</font> &lt;&lt; (<font color=#0000ff>long</font>)dp &lt;&lt; endl;
  dp++;
  cout &lt;&lt; <font color=#004488>"dp = "</font> &lt;&lt; (<font color=#0000ff>long</font>)dp &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">For one run on my machine, the output
is:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>ip = 6684124
ip = 6684128
dp = 6684044
dp = 6684052</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">What&#8217;s interesting here is that
even though the operation <B>++</B> appears to be the same operation for both
the <B>int*</B> and the <B>double*</B>, you can see that the pointer has been
changed only 4 bytes for the <B>int*</B> but 8 bytes for the <B>double*</B>. Not
coincidentally, these are the sizes of <B>int</B> and <B>double</B> on my
machine. And that&#8217;s the trick of pointer arithmetic: the compiler figures
out the right amount to change the pointer so that it&#8217;s pointing to the
next element in the array (pointer arithmetic is only meaningful within arrays).
This even works with arrays of <B>struct</B>s:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PointerIncrement2.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>typedef</font> <font color=#0000ff>struct</font> {
  <font color=#0000ff>char</font> c;
  <font color=#0000ff>short</font> s;
  <font color=#0000ff>int</font> i;
  <font color=#0000ff>long</font> l;
  <font color=#0000ff>float</font> f;
  <font color=#0000ff>double</font> d;
  <font color=#0000ff>long</font> <font color=#0000ff>double</font> ld;
} Primitives;

<font color=#0000ff>int</font> main() {
  Primitives p[10];
  Primitives* pp = p;
  cout &lt;&lt; <font color=#004488>"sizeof(Primitives) = "</font> 
       &lt;&lt; <font color=#0000ff>sizeof</font>(Primitives) &lt;&lt; endl;
  cout &lt;&lt; <font color=#004488>"pp = "</font> &lt;&lt; (<font color=#0000ff>long</font>)pp &lt;&lt; endl;
  pp++;
  cout &lt;&lt; <font color=#004488>"pp = "</font> &lt;&lt; (<font color=#0000ff>long</font>)pp &lt;&lt; endl;
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The output for one run on my machine
was:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>sizeof</font>(Primitives) = 40
pp = 6683764
pp = 6683804</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">So you can see the compiler also does the
right thing for pointers to <B>struct</B>s (and <B>class</B>es and
<B>union</B>s).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Pointer arithmetic also works with the
operators <A NAME="Index903"></A><B>--</B>, <A NAME="Index904"></A><B>+,</B> and
<A NAME="Index905"></A><B>-</B>, but the latter two operators are limited: you
cannot add two pointers, and if you subtract pointers the result is the number
of elements between the two pointers. However, you can add or subtract an
integral value and a pointer. Here&#8217;s an example demonstrating the use of
pointer arithmetic:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PointerArithmetic.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

#define P(EX) cout &lt;&lt; #EX &lt;&lt; <font color=#004488>": "</font> &lt;&lt; EX &lt;&lt; endl;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a[10];
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; 10; i++)
    a[i] = i; <font color=#009900>// Give it index values</font>
  <font color=#0000ff>int</font>* ip = a;
  P(*ip);
  P(*++ip);
  P(*(ip + 5));
  <font color=#0000ff>int</font>* ip2 = ip + 5;
  P(*ip2);
  P(*(ip2 - 4));
  P(*--ip2);
  P(ip2 - ip); <font color=#009900>// Yields number of elements</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It begins with another
<A NAME="Index906"></A>macro, but this one uses a
<A NAME="Index907"></A>preprocessor feature called
<A NAME="Index908"></A><I>stringizing</I> (implemented with the
&#8216;<B>#</B>&#8217; sign before an expression) that takes any expression and
turns it into a character array. This is quite convenient, since it allows the
expression to be printed, followed by a colon, followed by the value of the
expression. In <B>main(&#160;)</B> you can see the useful shorthand that is
produced.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although pre- and postfix versions of
<B>++</B> and <B>-- </B>are valid with pointers, only the prefix versions are
used in this example because they are applied before the pointers are
dereferenced in the expressions above, so they allow us to see the effects of
the operations. Note that only integral values are being added and subtracted;
if two pointers were combined this way the compiler would not allow it.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here is the output of the program
above:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>*ip: 0
*++ip: 1
*(ip + 5): 6
*ip2: 6
*(ip2 - 4): 2
*--ip2: 5</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In all cases, the pointer arithmetic
results in the pointer being adjusted to point to the &#8220;right place,&#8221;
based on the size of the elements being pointed to.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If pointer arithmetic seems a bit
overwhelming at first, don&#8217;t worry. Most of the time you&#8217;ll only
need to create arrays and index into them with <B>[&#160;]</B>, and the most
sophisticated pointer arithmetic you&#8217;ll usually need is <B>++</B> and
<B>--</B>. Pointer arithmetic is generally reserved for more clever and complex
programs, and many of the containers in the Standard C++ library hide most of
these clever details so you don&#8217;t have to worry about
them.</FONT><A NAME="_Toc462979792"></A><A NAME="_Toc472654798"></A><BR></P></DIV>
<A NAME="Heading168"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Debugging hints</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In an ideal environment, you have an
excellent debugger available that easily makes the behavior of your program
transparent so you can quickly discover errors. However, most debuggers have
blind spots, and these will require you to embed code snippets in your program
to help you understand what&#8217;s going on. In addition, you may be developing
in an environment (such as an embedded system, which is where I spent my
formative years) that has no debugger available, and perhaps very limited
feedback (i.e. a one-line LED display). In these cases you become creative in
the ways you discover and display information about the execution of your
program. This section suggests some techniques for doing
this.</FONT><A NAME="_Toc462979793"></A><A NAME="_Toc472654799"></A><BR></P></DIV>
<A NAME="Heading169"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Debugging flags<A NAME="Index909"></A><A NAME="Index910"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you hard-wire debugging code into a
program, you can run into problems. You start to get too much information, which
makes the bugs difficult to isolate. When you think you&#8217;ve found the bug
you start tearing out debugging code, only to find you need to put it back in
again. You can solve these problems with two types of flags: preprocessor
debugging flags and runtime debugging flags.</FONT><BR></P></DIV>
<A NAME="Heading170"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Preprocessor debugging flags<A NAME="Index911"></A><A NAME="Index912"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">By using the preprocessor to
<B>#define<A NAME="Index913"></A></B> one or more debugging flags (preferably in
a header file), you can test a flag using an
<B>#ifdef<A NAME="Index914"></A></B> statement and conditionally include
debugging code. When you think your debugging is finished, you can simply
<B>#undef<A NAME="Index915"></A></B> the flag(s) and the code will automatically
be removed (and you&#8217;ll reduce the size and runtime overhead of your
executable file).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It is best to decide on names for
debugging flags before you begin building your project so the names will be
consistent. Preprocessor flags are traditionally distinguished from variables by
writing them in all upper case. A common flag name is simply <B>DEBUG</B> (but
be careful you don&#8217;t use <B>NDEBUG</B>, which is reserved in C). The
sequence of statements might be:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#define DEBUG <font color=#009900>// Probably in a header file</font>
<font color=#009900>//...</font>
#ifdef DEBUG <font color=#009900>// Check to see if flag is defined</font>
<font color=#009900>/* debugging code here */</font>
#endif <font color=#009900>// DEBUG</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Most C and C++ implementations will also
let you <B>#define</B> and <B>#undef</B> flags from the compiler command line,
so you can re-compile code and insert debugging information with a single
command (preferably via the makefile, a tool that will be described shortly).
Check your local documentation  for details.</FONT><BR></P></DIV>
<A NAME="Heading171"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Runtime debugging flags<A NAME="Index916"></A><A NAME="Index917"></A></H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In some situations it is more convenient
to turn debugging flags on and off during program execution, especially by
setting them when the program starts up using the command line. Large programs
are tedious to recompile just to insert debugging code.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To turn debugging code on and off
dynamically, create <A NAME="Index918"></A><B>bool</B> flags:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:DynamicDebugFlags.cpp</font>
#include &lt;iostream&gt;
#include &lt;string&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;
<font color=#009900>// Debug flags aren't necessarily global:</font>
<font color=#0000ff>bool</font> debug = <font color=#0000ff>false</font>;

<font color=#0000ff>int</font> main(<font color=#0000ff>int</font> argc, <font color=#0000ff>char</font>* argv[]) {
  <font color=#0000ff>for</font>(<font color=#0000ff>int</font> i = 0; i &lt; argc; i++)
    <font color=#0000ff>if</font>(string(argv[i]) == <font color=#004488>"--debug=on"</font>)
      debug = <font color=#0000ff>true</font>;
  <font color=#0000ff>bool</font> go = <font color=#0000ff>true</font>;
  <font color=#0000ff>while</font>(go) {
    <font color=#0000ff>if</font>(debug) {
      <font color=#009900>// Debugging code here</font>
      cout &lt;&lt; <font color=#004488>"Debugger is now on!"</font> &lt;&lt; endl;
    } <font color=#0000ff>else</font> {
      cout &lt;&lt; <font color=#004488>"Debugger is now off."</font> &lt;&lt; endl;
    }  
    cout &lt;&lt; <font color=#004488>"Turn debugger [on/off/quit]: "</font>;
    string reply;
    cin &gt;&gt; reply;
    <font color=#0000ff>if</font>(reply == <font color=#004488>"on"</font>) debug = <font color=#0000ff>true</font>; <font color=#009900>// Turn it on</font>
    <font color=#0000ff>if</font>(reply == <font color=#004488>"off"</font>) debug = <font color=#0000ff>false</font>; <font color=#009900>// Off</font>
    <font color=#0000ff>if</font>(reply == <font color=#004488>"quit"</font>) <font color=#0000ff>break</font>; <font color=#009900>// Out of 'while'</font>
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This program continues to allow you to
turn the debugging flag on and off until you type &#8220;quit&#8221; to tell it
you want to exit. Notice it requires that full words are typed in, not just
letters (you can shorten it to letter if you wish). Also, a command-line
argument can optionally be used to turn debugging on at startup &#8211; this
argument can appear anyplace in the command line, since the startup code in
<B>main(&#160;)</B> looks at all the arguments. The testing is quite simple
because of the expression:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>string(argv[i])</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This takes the <B>argv[i]</B> character
array and creates a <B>string</B>, which then can be easily compared to the
right-hand side of the <B>==</B>. The program above searches for the entire
string <B>--debug=on</B>. You can also look for <B>--debug=</B> and then see
what&#8217;s after that, to provide more options. Volume 2 (available from
<I>www.BruceEckel.com</I>) devotes a chapter to the Standard C++ <B>string</B>
class.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Although a debugging flag is one of the
relatively few areas where it makes a lot of sense to use a global variable,
there&#8217;s nothing that says it must be that way. Notice that the variable is
in lower case letters to remind the reader it isn&#8217;t a preprocessor
flag.</FONT><A NAME="_Toc462979794"></A><A NAME="_Toc472654800"></A><BR></P></DIV>
<A NAME="Heading172"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Turning variables and expressions into
string<A NAME="Index919"></A><A NAME="Index920"></A>s</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When writing debugging code, it is
tedious to write print expressions consisting of a character array containing
the variable name, followed by the variable. Fortunately, Standard C includes
the
<A NAME="Index921"></A><A NAME="Index922"></A><A NAME="Index923"></A><I>stringize</I>
operator &#8216;<B>#</B>&#8217;, which was used earlier in this chapter. When
you put a <B>#</B> before an argument in a preprocessor macro, the preprocessor
turns that argument into a character array. This, combined with the fact that
character arrays with no intervening punctuation are concatenated into a single
character array, allows you to make a very convenient macro for printing the
values of variables during debugging:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#define PR(x) cout &lt;&lt; #x <font color=#004488>" = "</font> &lt;&lt; x &lt;&lt; <font color=#004488>"\n"</font>;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you print the variable <B>a</B> by
calling the macro <B>PR(a)</B>, it will have the same effect as the
code:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>cout &lt;&lt; <font color=#004488>"a = "</font> &lt;&lt; a &lt;&lt; <font color=#004488>"\n"</font>;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This same process works with entire
expressions. The following program uses a macro to create a shorthand that
prints the stringized expression and then evaluates the expression and prints
the result:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:StringizingExpressions.cpp</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

#define P(A) cout &lt;&lt; #A &lt;&lt; <font color=#004488>": "</font> &lt;&lt; (A) &lt;&lt; endl;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> a = 1, b = 2, c = 3;
  P(a); P(b); P(c);
  P(a + b);
  P((c - a)/b);
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see how a technique like this can
quickly become indispensable, especially if you have no debugger (or must use
multiple development environments). You can also insert an <B>#ifdef</B> to
cause <B>P(A)</B> to be defined as &#8220;nothing&#8221; when you want to strip
out
debugging.</FONT><A NAME="_Toc462979795"></A><A NAME="_Toc472654801"></A><BR></P></DIV>
<A NAME="Heading173"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
The C assert(&#160;) macro<A NAME="Index924"></A><A NAME="Index925"></A></H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">In the standard header file
<A NAME="Index926"></A><A NAME="Index927"></A><B>&lt;cassert&gt;
</B>you&#8217;ll find <B>assert(&#160;)</B>, which is a convenient debugging
macro. When you use <B>assert(&#160;)</B>, you give it an argument that is an
expression you are &#8220;asserting to be true.&#8221; The preprocessor
generates code that will test the assertion. If the assertion isn&#8217;t true,
the program will stop after issuing an error message telling you what the
assertion was and that it failed. Here&#8217;s a trivial
example:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:Assert.cpp</font>
<font color=#009900>// Use of the assert() debugging macro</font>
#include &lt;cassert&gt;  <font color=#009900>// Contains the macro</font>
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>int</font> i = 100;
  assert(i != 100); <font color=#009900>// Fails</font>
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The macro originated in Standard C, so
it&#8217;s also available in the header file <B>assert.h</B>. </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you are finished debugging, you can
remove the code generated by the macro by placing the line:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>#define NDEBUG</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><A NAME="Index928"></A><FONT FACE="Georgia">in the program
before the inclusion of <B>&lt;cassert&gt;</B>, or by defining NDEBUG on the
compiler command line. NDEBUG is a flag used in <B>&lt;cassert&gt; </B>to change
the way code is generated by the macros.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Later in this book, you&#8217;ll see some
more sophisticated alternatives to <B>assert(&#160;)</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index929"></A><A NAME="Index930"></A><A NAME="_Toc462979796"></A><A NAME="_Toc472654802"></A><BR></P></DIV>
<A NAME="Heading174"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Function addresses</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once a function is compiled and loaded
into the computer to be executed, it occupies a chunk of memory. That memory,
and thus the function, has an address.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">C has never been a language to bar entry
where others fear to tread. You can use function addresses with pointers just as
you can use variable addresses. The declaration and use of function pointers
looks a bit opaque at first, but it follows the format of the rest of the
language.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index931"></A><A NAME="Index932"></A><A NAME="Index933"></A><A NAME="_Toc462979797"></A><A NAME="_Toc472654803"></A><BR></P></DIV>
<A NAME="Heading175"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Defining a function pointer</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To define a pointer to a function that
has no arguments and no return value, you say:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> (*funcPtr)();</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you are looking at a
<A NAME="Index934"></A><A NAME="Index935"></A>complex definition like this, the
best way to attack it is to start in the middle and work your way out.
&#8220;Starting in the middle&#8221; means starting at the variable name, which
is <B>funcPtr</B>. &#8220;Working your way out&#8221; means looking to the right
for the nearest item (nothing in this case; the right parenthesis stops you
short), then looking to the left (a pointer denoted by the asterisk), then
looking to the right (an empty argument list indicating a function that takes no
arguments), then looking to the left (<B>void,</B> which indicates the function
has no return value). This right-left-right motion works with most
declarations.<A NAME="Index936"></A></FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">To review, &#8220;start in the
middle&#8221; (&#8220;<B>funcPtr</B> is a ...&#8221;), go to the right (nothing
there &#8211; you're stopped by the right parenthesis), go to the left and find
the &#8216;<B>*</B>&#8217; (&#8220;... pointer to a ...&#8221;), go to the right
and find the empty argument list (&#8220;... function that takes no arguments
... &#8221;), go to the left and find the <B>void</B> (&#8220;<B>funcPtr</B> is
a pointer to a function that takes no arguments and returns
<B>void</B>&#8221;).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You may wonder why <B>*funcPtr</B>
requires parentheses. If you didn't use them, the compiler would
see:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#0000ff>void</font> *funcPtr();</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You would be declaring a function (that
returns a <B>void*</B>)<B> </B>rather than defining a variable. You can think of
the compiler as going through the same process you do when it figures out what a
declaration or definition is supposed to be. It needs those parentheses to
&#8220;bump up against&#8221; so it goes back to the left and finds the
&#8216;<B>*</B>&#8217;, instead of continuing to the right and finding the empty
argument list.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index937"></A><A NAME="_Toc462979798"></A><A NAME="_Toc472654804"></A><BR></P></DIV>
<A NAME="Heading176"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Complicated declarations &amp; definitions</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As an aside, once you figure out how the
C and C++ declaration syntax works you can create much more complicated items.
For instance:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:ComplicatedDefinitions.cpp</font>

<font color=#009900>/* 1. */</font>     <font color=#0000ff>void</font> * (*(*fp1)(<font color=#0000ff>int</font>))[10];

<font color=#009900>/* 2. */</font>     <font color=#0000ff>float</font> (*(*fp2)(<font color=#0000ff>int</font>,<font color=#0000ff>int</font>,<font color=#0000ff>float</font>))(<font color=#0000ff>int</font>);

<font color=#009900>/* 3. */</font>     <font color=#0000ff>typedef</font> <font color=#0000ff>double</font> (*(*(*fp3)())[10])();
             fp3 a;

<font color=#009900>/* 4. */</font>     <font color=#0000ff>int</font> (*(*f4())[10])();

<font color=#0000ff>int</font> main() {} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Walk through each one and use the
right-left guideline to figure it out. Number 1 says &#8220;<B>fp1</B> is a
pointer to a function that takes an integer argument and returns a pointer to an
array of 10 <B>void</B> pointers.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Number 2 says &#8220;<B>fp2</B> is a
pointer to a function that takes three arguments (<B>int</B>, <B>int,</B> and
<B>float</B>) and returns a pointer to a function that takes an integer argument
and returns a <B>float</B>.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you are creating a lot of complicated
definitions, you might want to use a <B>typedef</B>. Number 3 shows how a
<B>typedef</B> saves typing the complicated description every time. It says
&#8220;An <B>fp3</B> is a pointer to a function that takes no arguments and
returns a pointer to an array of 10 pointers to functions that take no arguments
and return doubles.&#8221; Then it says &#8220;<B>a</B> is one of these
<B>fp3</B> types.&#8221; <B>typedef</B> is generally useful for building
complicated descriptions from simple ones.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Number 4 is a function declaration
instead of a variable definition. It says &#8220;<B>f4</B> is a function that
returns a pointer to an array of 10 pointers to functions that return
integers.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You will rarely if ever need such
complicated declarations and definitions as these. However, if you go through
the exercise of figuring them out you will not even be mildly disturbed with the
slightly complicated ones you may encounter in real life.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index938"></A><A NAME="_Toc462979799"></A><A NAME="_Toc472654805"></A><BR></P></DIV>
<A NAME="Heading177"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Using a function pointer</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once you define a
<A NAME="Index939"></A>pointer to a function, you must assign it to a function
address before you can use it. Just as the address of an array <B>arr[10]</B> is
produced by the array name without the brackets (<B>arr</B>), the address of a
function<B> func() </B>is produced by the function name without the argument
list (<B>func</B>). You can also use the more explicit syntax
<B>&amp;func()</B>. To call the function, you <A NAME="Index940"></A>dereference
the pointer in the same way that you declared it (remember that C and C++ always
try to make definitions look the same as the way they are used). The following
example shows how a pointer to a function is defined and used:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:PointerToFunction.cpp</font>
<font color=#009900>// Defining and using a pointer to a function</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#0000ff>void</font> func() {
  cout &lt;&lt; <font color=#004488>"func() called..."</font> &lt;&lt; endl;
}

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>void</font> (*fp)();  <font color=#009900>// Define a function pointer</font>
  fp = func;  <font color=#009900>// Initialize it</font>
  (*fp)();    <font color=#009900>// Dereferencing calls the function</font>
  <font color=#0000ff>void</font> (*fp2)() = func;  <font color=#009900>// Define and initialize</font>
  (*fp2)();
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the pointer to function <B>fp</B>
is defined, it is assigned to the address of a function <B>func()</B> using
<B>fp = func</B> (notice the argument list is missing on the function name). The
second case shows simultaneous definition and initialization.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="Index941"></A><A NAME="Index942"></A><A NAME="Index943"></A><A NAME="_Toc462979800"></A><A NAME="_Toc472654806"></A><BR></P></DIV>
<A NAME="Heading178"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Arrays of pointers to functions</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">One of the more interesting constructs
you can create is an array of pointers to functions. To select a function, you
just index into the array and dereference the pointer. This supports the concept
of <A NAME="Index944"></A><A NAME="Index945"></A><I>table-driven code</I>;
instead of using conditionals or case statements, you select functions to
execute based on a state variable (or a combination of state variables). This
kind of design can be useful if you often add or delete functions from the table
(or if you want to create or change such a table dynamically).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The following example creates some dummy
functions using a preprocessor macro, then creates an array of pointers to those
functions using automatic
<A NAME="Index946"></A><A NAME="Index947"></A>aggregate initialization. As you
can see, it is easy to add or remove functions from the table (and thus,
functionality from the program) by changing a small amount of
code:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE><font color=#009900>//: C03:FunctionTable.cpp</font>
<font color=#009900>// Using an array of pointers to functions</font>
#include &lt;iostream&gt;
<font color=#0000ff>using</font> <font color=#0000ff>namespace</font> std;

<font color=#009900>// A macro to define dummy functions:</font>
#define DF(N) <font color=#0000ff>void</font> N() { \
   cout &lt;&lt; <font color=#004488>"function "</font> #N <font color=#004488>" called..."</font> &lt;&lt; endl; }

DF(a); DF(b); DF(c); DF(d); DF(e); DF(f); DF(g);

<font color=#0000ff>void</font> (*func_table[])() = { a, b, c, d, e, f, g };

<font color=#0000ff>int</font> main() {
  <font color=#0000ff>while</font>(1) {
    cout &lt;&lt; <font color=#004488>"press a key from 'a' to 'g' "</font>
      <font color=#004488>"or q to quit"</font> &lt;&lt; endl;
    <font color=#0000ff>char</font> c, cr;
    cin.get(c); cin.get(cr); <font color=#009900>// second one for CR</font>
    <font color=#0000ff>if</font> ( c == 'q' ) 
      <font color=#0000ff>break</font>; <font color=#009900>// ... out of while(1)</font>
    <font color=#0000ff>if</font> ( c &lt; 'a' || c &gt; 'g' ) 
      <font color=#0000ff>continue</font>;
    (*func_table[c - 'a'])();
  }
} <font color=#009900>///:~</font></PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">At this point, you might be able to
imagine how this technique could be useful when creating some sort of
interpreter or list processing
program.</FONT><A NAME="_Toc462979801"></A><A NAME="_Toc472654807"></A><BR></P></DIV>
<A NAME="Heading179"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Make<A NAME="Index948"></A>: managing separate compilation</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When using <I>separate compilation</I>
<A NAME="Index949"></A><A NAME="Index950"></A>(breaking code into a number of
translation units), you need some way to automatically compile each file and to
tell the linker to build all the pieces &#8211; along with the appropriate
libraries and startup code &#8211; into an executable file. Most compilers allow
you to do this with a single command-line statement. For the GNU C++ compiler,
for example, you might say</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>g++ SourceFile1.cpp SourceFile2.cpp</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The problem with this approach is that
the compiler will first compile each individual file, regardless of whether that
file <I>needs</I> to be rebuilt or not. With many files in a project, it can
become prohibitive to recompile everything if you&#8217;ve changed only a single
file.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The solution to this problem, developed
on Unix but available everywhere in some form, is a program called <B>make</B>.
The <B>make</B> utility manages all the individual files in a project by
following the instructions in a text file called a
<A NAME="Index951"></A><B>makefile</B>. When you edit some of the files in a
project and type <B>make</B>, the <B>make</B> program follows the guidelines in
the <B>makefile </B>to compare the dates on the source code files to the dates
on the corresponding target files, and if a source code file date is more recent
than its target file, <B>make</B> invokes the compiler on the source code file.
<B>make</B> only recompiles the source code files that were changed, and any
other source-code files that are affected by the modified files. By using
<B>make</B>, you don&#8217;t have to re-compile all the files in your project
every time you make a change, nor do you have to check to see that everything
was built properly. The <B>makefile</B> contains all the commands to put your
project together. Learning to use <B>make</B> will save you a lot of time and
frustration. You&#8217;ll also discover that <B>make</B> is the typical way that
you install new software on a Linux/Unix machine (although those
<B>makefile</B>s tend to be far more complicated than the ones presented in this
book, and you&#8217;ll often automatically generate a <B>makefile</B> for your
particular machine as part of the installation process).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Because <B>make</B> is available in some
form for virtually all C++ compilers (and even if it isn&#8217;t, you can use
freely-available <B>make</B>s with any compiler), it will be the tool used
throughout this book. However, compiler vendors have also created their own
project building tools<A NAME="Index952"></A>. These tools ask you which files
are in your project and determine all the relationships themselves. These tools
use something similar to a <B>makefile</B>, generally called a <I>project
file</I>, but the programming environment maintains this file so you don&#8217;t
have to worry about it. The configuration and use of project files varies from
one development environment to another, so you must find the appropriate
documentation on how to use them (although project file tools provided by
compiler vendors are usually so simple to use that you can learn them by playing
around &#8211; my favorite form of education). </FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>makefile</B>s used within this
book should work even if you are also using a specific vendor&#8217;s
project-building
tool.</FONT><A NAME="_Toc462979802"></A><A NAME="_Toc472654808"></A><BR></P></DIV>
<A NAME="Heading180"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Make activities</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">When you type <B>make</B> (or whatever
the name of your &#8220;make&#8221; program happens to be), the <B>make</B>
program looks in the current directory for a file named <B>makefile</B>, which
you&#8217;ve created if it&#8217;s your project. This file lists
<A NAME="Index953"></A>dependencies<A NAME="Index954"></A> between source code
files. <B>make</B> looks at the dates on files. If a dependent file has an older
date than a file it depends on, <B>make</B> executes the
<A NAME="Index955"></A><I>rule</I> given after the dependency.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">All <A NAME="Index956"></A>comments in
<B>makefile</B>s start with a <B>#</B> and continue to the end of the
line.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As a simple example, the <B>makefile</B>
for a program called &#8220;hello&#8221; might contain:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE># A comment
hello.exe: hello.cpp
        mycompiler hello.cpp</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This says that <B>hello.exe</B> (the
target) depends on <B>hello.cpp</B>. When <B>hello.cpp</B> has a newer date than
<B>hello.exe</B>, <B>make</B> executes the &#8220;rule&#8221; <B>mycompiler
hello.cpp</B>. There may be multiple dependencies and multiple rules. Many
<B>make</B> programs require that all the rules begin with a tab. Other than
that, whitespace is generally ignored so you can format for
readability.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The rules are not restricted to being
calls to the compiler; you can call any program you want from within
<B>make</B>. By creating groups of interdependent dependency-rule sets, you can
modify your source code files, type <B>make</B> and be certain that all the
affected files will be rebuilt correctly.</FONT><BR></P></DIV>
<A NAME="Heading181"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Macros</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">A <B>makefile</B> may contain
<A NAME="Index957"></A><I>macros</I> (note that these are completely different
from C/C++ preprocessor macros)<A NAME="Index958"></A>. Macros allow convenient
string replacement. The <B>makefile</B>s in this book use a macro to invoke the
C++ compiler. For example,</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CPP = mycompiler
hello.exe: hello.cpp
        $(CPP) hello.cpp</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The <B>= </B>is used to identify <B>CPP
</B>as a macro, and the <B>$</B> and parentheses expand the macro. In this case,
the expansion means that the macro call <B>$(CPP)</B> will be replaced with the
string <B>mycompiler</B>. With the macro above, if you want to change to a
different compiler called <B>cpp</B>,<B> </B>you just change the macro
to:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CPP = cpp</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can also add compiler flags, etc., to
the macro, or use separate macros to add compiler flags.</FONT><BR></P></DIV>
<A NAME="Heading182"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Suffix Rules</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">It becomes tedious to tell <B>make</B>
how to invoke the compiler for every single<B> cpp</B> file in your project,
when you know it&#8217;s the same basic process each time. Since <B>make</B> is
designed to be a time-saver, it also has a way to abbreviate actions, as long as
they depend on file name suffixes. These abbreviations are called
<A NAME="Index959"></A><A NAME="Index960"></A><I>suffix rules</I>. A suffix rule
is the way to teach <B>make</B> how to convert a file with one type of extension
(<B>.cpp</B>, for example) into a file with another type of extension
(<B>.obj</B> or <B>.exe</B>). Once you teach <B>make</B> the rules for producing
one kind of file from another, all you have to do is tell <B>make</B> which
files depend on which other files. When <B>make</B> finds a file with a date
earlier than the file it depends on, it uses the rule to create a new file.
</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The suffix rule tells <B>make</B> that it
doesn&#8217;t need explicit rules to build everything, but instead it can figure
out how to build things based on their file extension. In this case it says
&#8220;To build a file that ends in <B>exe</B> from one that ends in <B>cpp</B>,
invoke the following command.&#8221; Here&#8217;s what it looks like for the
example above:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CPP = mycompiler
.SUFFIXES: .exe .cpp
.cpp.exe:
        $(CPP) $&lt;</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The
<A NAME="Index961"></A><A NAME="Index962"></A><B>.SUFFIXES</B> directive tells
<B>make</B> that it should watch out for any of the following file-name
extensions because they have special meaning for this particular makefile. Next
you see the suffix rule <B>.cpp.exe,</B> which says &#8220;Here&#8217;s how to
convert any file with an extension of <B>cpp</B> to one with an extension of
<B>exe</B>&#8221; (when the <B>cpp</B> file is more recent than the <B>exe</B>
file). As before, the <B>$(CPP)</B> macro is used, but then you see something
new: <A NAME="Index963"></A><B>$&lt;</B>. Because this begins with a
&#8216;<B>$</B>&#8217; it&#8217;s a macro, but this is one of
<B>make</B>&#8217;s special built-in macros. The <B>$&lt; </B>can be used only
in suffix rules, and it means &#8220;whatever prerequisite triggered the
rule&#8221; (sometimes called the <I>dependent</I>), which in this case
translates to &#8220;the <B>cpp</B> file that needs to be
compiled.&#8221;</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Once the suffix rules have been set up,
you can simply say, for example, &#8220;<B>make Union.exe</B>,&#8221; and the
suffix rule will kick in, even though there&#8217;s no mention of
&#8220;Union&#8221; anywhere in the <B>makefile</B>. </FONT><BR></P></DIV>
<A NAME="Heading183"></A><FONT FACE = "Verdana"><H4 ALIGN="LEFT">
Default targets</H4></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">After the macros and suffix rules,
<B>make</B> looks for the first &#8220;target&#8221; in a file, and builds that,
unless you specify differently. So for the following
<B>makefile</B>:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CPP = mycompiler
.SUFFIXES: .exe .cpp
.cpp.exe:
        $(CPP) $&lt;
target1.exe:
target2.exe: </PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">If you just type
&#8216;<B>make</B>&#8217;, then <B>target1.exe</B> will be built (using the
default suffix rule) because that&#8217;s the first target that <B>make</B>
encounters. To build <B>target2.exe</B> you&#8217;d have to explicitly say
&#8216;<B>make target2.exe</B>&#8217;. This becomes tedious, so you normally
create a default &#8220;dummy&#8221; target that depends on all the rest of the
targets, like this:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CPP = mycompiler
.SUFFIXES: .exe .cpp
.cpp.exe:
        $(CPP) $&lt;
all: target1.exe target2.exe</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Here, &#8216;<B>all</B>&#8217; does not
exist and there&#8217;s no file called &#8216;<B>all</B>&#8217;, so every time
you type <B>make</B>, the program sees &#8216;<B>all</B>&#8217; as the first
target in the list (and thus the default target), then it sees that
&#8216;<B>all</B>&#8217; does not exist so it had better make it by checking all
the dependencies. So it looks at <B>target1.exe</B> and (using the suffix rule)
sees whether (1) <B>target1.exe</B> exists and (2) whether <B>target1.cpp</B> is
more recent than <B>target1.exe</B>, and if so runs the suffix rule (if you
provide an explicit rule for a particular target, that rule is used instead).
Then it moves on to the next file in the default target list. Thus, by creating
a default target list (typically called &#8216;<B>all</B>&#8217; by convention,
but you can call it anything) you can cause every executable in your project to
be made simply by typing &#8216;<B>make</B>&#8217;. In addition, you can have
other non-default target lists that do other things &#8211; for example, you
could set it up so that typing &#8216;<B>make debug</B>&#8217; rebuilds all your
files with debugging wired
in.</FONT><A NAME="_Toc462979803"></A><A NAME="_Toc472654809"></A><BR></P></DIV>
<A NAME="Heading184"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
Makefiles in this book</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Using the program <B>ExtractCode.cpp</B>
from Volume 2 of this book, all the code listings in this book are automatically
extracted from the ASCII text version of this book and placed in subdirectories
according to their chapters. In addition, <B>ExtractCode.cpp </B>creates several
<B>makefile</B>s in each subdirectory (with different names) so you can simply
move into that subdirectory and type <B>make -f mycompiler.makefile</B>
(substituting the name of your compiler for &#8216;<B>mycompiler</B>&#8217;, the
&#8216;<B>-f</B>&#8217; flag says &#8220;use what follows as the
<B>makefile</B>&#8221;). Finally, <B>ExtractCode.cpp</B> creates a
&#8220;master&#8221; <B>makefile</B> in the root directory where the
book&#8217;s files have been expanded, and this <B>makefile</B> descends into
each subdirectory and calls <B>make</B> with the appropriate <B>makefile</B>.
This way you can compile all the code in the book by invoking a single
<B>make</B> command, and the process will stop whenever your compiler is unable
to handle a particular file (note that a Standard C++ conforming compiler should
be able to compile all the files in this book). Because implementations of
<B>make</B> vary from system to system, only the most basic, common features are
used in the generated <B>makefile</B>s.
</FONT><A NAME="_Toc462979804"></A><A NAME="_Toc472654810"></A><BR></P></DIV>
<A NAME="Heading185"></A><FONT FACE = "Verdana"><H3 ALIGN="LEFT">
An example makefile</H3></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">As mentioned, the code-extraction tool
<B>ExtractCode.cpp</B> automatically generates <B>makefile</B>s for each
chapter. Because of this, the <B>makefile</B>s for each chapter will not be
placed in the book (all the makefiles are packaged with the source code, which
you can download from <I>www.BruceEckel.com</I>).<B> </B>However, it&#8217;s
useful to see an example of a <B>makefile</B>. What follows is a shortened
version of the one that was automatically generated for this chapter by the
book&#8217;s extraction tool. You&#8217;ll find more than one <B>makefile</B> in
each subdirectory (they have different names; you invoke a specific one with
&#8216;<B>make -f</B>&#8217;). This one is for GNU C++:</FONT><BR></P></DIV>

<BLOCKQUOTE><FONT SIZE = "+1"><PRE>CPP = g++
OFLAG = -o
.SUFFIXES : .o .cpp .c
.cpp.o :
  $(CPP) $(CPPFLAGS) -c $&lt;
.c.o :
  $(CPP) $(CPPFLAGS) -c $&lt;

all: \
  Return \
  Declare \
  Ifthen \
  Guess \
  Guess2
# Rest of the files <font color=#0000ff>for</font> <font color=#0000ff>this</font> chapter not shown

Return: Return.o 
  $(CPP) $(OFLAG)Return Return.o 

Declare: Declare.o 
  $(CPP) $(OFLAG)Declare Declare.o 

Ifthen: Ifthen.o 
  $(CPP) $(OFLAG)Ifthen Ifthen.o 

Guess: Guess.o 
  $(CPP) $(OFLAG)Guess Guess.o 

Guess2: Guess2.o 
  $(CPP) $(OFLAG)Guess2 Guess2.o 

Return.o: Return.cpp 
Declare.o: Declare.cpp 
Ifthen.o: Ifthen.cpp 
Guess.o: Guess.cpp 
Guess2.o: Guess2.cpp</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The macro CPP is set to the name of the
compiler. To use a different compiler, you can either edit the <B>makefile</B>
or change the value of the macro on the command line, like
this:</FONT><BR></P></DIV>
<BLOCKQUOTE><FONT SIZE = "+1"><PRE>make CPP=cpp</PRE></FONT></BLOCKQUOTE>

<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">Note, however, that
<B>ExtractCode.cpp</B> has an automatic scheme to automatically build
<B>makefile</B>s for additional compilers.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The second macro <B>OFLAG</B> is the flag
that&#8217;s used to indicate the name of the output file. Although many
compilers automatically assume the output file has the same base name as the
input file, others don&#8217;t (such as Linux/Unix compilers, which default to
creating a file called <B>a.out</B>).</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">You can see that there are two suffix
rules here, one for<B> cpp</B> files and one for <B>.c</B> files (in case any C
source code needs to be compiled). The default target is <B>all</B>, and each
line for this target is &#8220;continued&#8221; by using the backslash, up until
<B>Guess2</B>, which is the last one in the list and thus has no backslash.
There are many more files in this chapter, but only these are shown here for the
sake of brevity.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">The suffix rules take care of creating
object files (with a <B>.o </B>extension) from <B>cpp </B>files, but in general
you need to explicitly state rules for creating the executable, because normally
an executable is created by linking many different object files and <B>make</B>
cannot guess what those are. Also, in this case (Linux/Unix) there is no
standard extension for executables so a suffix rule won&#8217;t work for these
simple situations. Thus, you see all the rules for building the final
executables explicitly stated.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This <B>makefile</B> takes the absolute
safest route of using as few <B>make</B> features as possible; it only uses the
basic <B>make</B> concepts of targets and dependencies, as well as macros. This
way it is virtually assured of working with as many <B>make</B> programs as
possible. It tends to produce a larger <B>makefile</B>, but that&#8217;s not so
bad since it&#8217;s automatically generated by
<B>ExtractCode.cpp</B>.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">There are lots of other <B>make</B>
features that this book will not use, as well as newer and cleverer versions and
variations of <B>make</B> with advanced shortcuts that can save a lot of time.
Your local documentation may describe the further features of your particular
<B>make</B>, and you can learn more about <B>make</B> from <I>Managing Projects
with Make</I> by Oram and Talbott (O&#8217;Reilly, 1993). Also, if your compiler
vendor does not supply a <B>make</B> or it uses a non-standard <B>make</B>, you
can find GNU make for virtually any platform in existence by searching the
Internet for GNU archives (of which there are
many).</FONT><A NAME="_Toc462979805"></A><A NAME="_Toc472654811"></A><BR></P></DIV>
<A NAME="Heading186"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Summary</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia">This chapter was a fairly intense tour
through all the fundamental features of C++ syntax, most of which are inherited
from and in common with C (and result in C++&#8217;s vaunted backwards
compatibility with C). Although some C++ features were introduced here, this
tour is primarily intended for people who are conversant in programming, and
simply need to be given an introduction to the syntax basics of C and C++. If
you&#8217;re already a C programmer, you may have even seen one or two things
about C here that were unfamiliar, aside from the C++ features that were most
likely new to you. However, if this chapter has still seemed a bit overwhelming,
you should go through the CD ROM course <I>Thinking in C: Foundations for C++
and Java</I> (which contains lectures, exercises, and guided solutions), which
is bound into this book, and also available at
<I>www.BruceEckel.com</I>.</FONT><A NAME="_Toc462979806"></A><A NAME="_Toc472654812"></A><BR></P></DIV>
<A NAME="Heading187"></A><FONT FACE = "Verdana"><H2 ALIGN="LEFT">
Exercises</H2></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Georgia" SIZE=2>Solutions to selected exercises
can be found in the electronic document <I>The Thinking in C++ Annotated
Solution Guide</I>, available for a small fee from
www.BruceEckel.com.</FONT><BR></P></DIV>
<OL>
<LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a header file (with
an extension of &#8216;<B>.h</B>&#8217;). In this file, declare a group of
functions by varying the argument lists and return values from among the
following: <B>void</B>, <B>char</B>, <B>int</B>, and <B>float</B>. Now create a
<B>.cpp</B> file that includes your header file and creates definitions for all
of these functions. Each definition should simply print out the function name,
argument list, and return type so you know it&#8217;s been called. Create a
second <B>.cpp</B> file that includes your header file and defines <B>int
main(&#160;)</B>, containing calls to all of your functions. Compile and run
your program.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write
a program that uses two nested <B>for</B> loops and the modulus operator
(<B>%</B>) to detect and print prime numbers (integral numbers that are not
evenly divisible by any other numbers except for themselves and
1).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write a program
that uses a <B>while </B>loop to read words from standard input (<B>cin</B>)
into a <B>string</B>. This is an &#8220;infinite&#8221; <B>while</B> loop, which
you break out of (and exit the program) using a <B>break</B> statement. For each
word that is read, evaluate it<B> </B>by first using a sequence of <B>if</B>
statements to &#8220;map&#8221; an integral value to the word, and then use a
<B>switch</B> statement that uses that integral value as its selector (this
sequence of events is not meant to be good programming style; it&#8217;s just
supposed to give you exercise with control flow). Inside each <B>case</B>,<B>
</B>print something meaningful. You must decide what the
&#8220;interesting&#8221; words are and what the meaning is. You must also
decide what word will signal the end of the program. Test the program by
redirecting a file into the program&#8217;s standard input (if you want to save
typing, this file can be your program&#8217;s source
file).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Menu.cpp</B> to use <B>switch</B> statements instead of <B>if</B>
statements.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write a
program that evaluates the two expressions in the section labeled
&#8220;precedence.&#8221;</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>YourPets2.cpp</B> so that it uses various different data types (<B>char</B>,
<B>int</B>, <B>float</B>, <B>double,</B> and their variants). Run the program
and create a map of the resulting memory layout. If you have access to more than
one kind of machine, operating system, or compiler, try this experiment with as
many variations as you can
manage.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create two
functions, one that takes a <B>string*</B> and one that takes a
<B>string&amp;</B>. Each of these functions should modify the outside <B>string
</B>object in its own unique way. In <B>main(&#160;)</B>, create and initialize
a <B>string</B> object, print it, then pass it to each of the two functions,
printing the
results.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Write a
program that uses all the trigraphs to see if your compiler supports
them.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Compile and
run <B>Static.cpp</B>. Remove the <B>static</B> keyword from the code, compile
and run it again, and explain what
happens.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Try to
compile and link <B>FileStatic.cpp</B> with <B>FileStatic2.cpp</B>. What does
the resulting error message
mean?</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Boolean.cpp</B> so that it works with <B>double</B> values instead of
<B>int</B>s.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Boolean.cpp</B> and <B>Bitwise.cpp</B> so they use the explicit operators (if
your compiler is conformant to the C++ Standard it will support
these).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Bitwise.cpp</B> to use the functions from <B>Rotation.cpp</B>. Make sure you
display the results in such a way that it&#8217;s clear what&#8217;s happening
during
rotations.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>Ifthen.cpp</B> to use the ternary <B>if-else</B> operator
(<B>?:</B>).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a <B>struct</B> that holds two <B>string</B> objects and one <B>int</B>. Use a
<B>typedef</B> for the <B>struct</B> name. Create an instance of the
<B>struct</B>,<B> </B>initialize all three values in your instance, and print
them out. Take the address of your instance and assign it to a pointer to your
<B>struct</B> type. Change the three values in your instance and print them out,
all using the
pointer.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
program that uses an enumeration of colors. Create a variable of this
<B>enum</B> type and print out all the numbers that correspond with the color
names, using a <B>for</B>
loop.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Experiment
with <B>Union.cpp</B> by removing various <B>union</B> elements to see the
effects on the size of the resulting <B>union</B>. Try assigning to one element
(thus one type) of the <B>union</B> and printing out a via a different element
(thus a different type) to see what
happens.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
program that defines two <B>int</B> arrays, one right after the other. Index off
the end of the first array into the second, and make an assignment. Print out
the second array to see the changes cause by this. Now try defining a
<B>char</B> variable between the first array definition and the second, and
repeat the experiment. You may want to create an array printing function to
simplify your
coding.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>ArrayAddresses.cpp</B> to work with the data types <B>char</B>, <B>long
int</B>, <B>float,</B> and
<B>double</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Apply
the technique in <B>ArrayAddresses.cpp</B> to print out the size of the
<B>struct</B> and the addresses of the array elements in
<B>StructArray.cpp</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
an array of <B>string</B> objects and assign a string to each element. Print out
the array using a <B>for</B>
loop.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create two new
programs starting from <B>ArgsToInts.cpp</B> so they use <B>atol(&#160;)</B> and
<B>atof(&#160;)</B>,
respectively.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>PointerIncrement2.cpp</B> so it uses a <B>union</B> instead of a
<B>struct</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>PointerArithmetic.cpp</B> to work with <B>long</B> and <B>long
double</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Define a
<B>float</B> variable. Take its address, cast that address to an <B>unsigned
char</B>, and assign it to an <B>unsigned char</B> pointer. Using this pointer
and <B>[&#160;]</B>, index into the <B>float</B> variable and use the
<B>printBinary(&#160;) </B>function defined in this chapter to print out a map
of the <B>float</B> (go from 0 to <B>sizeof(float)</B>). Change the value of the
<B>float</B> and see if you can figure out what&#8217;s going on (the
<B>float</B> contains encoded
data).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Define an
array of <B>int</B>. Take the starting address of that array and use
<B>static_cast</B> to convert it into an <B>void*</B>. Write a function that
takes a <B>void*</B>, a number (indicating a number of bytes), and a value
(indicating the value to which each byte should be set) as arguments. The
function should set each byte in the specified range to the specified value. Try
out the function on your array of
<B>int</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
<B>const</B> array of <B>double</B> and a <B>volatile</B> array of
<B>double</B>. Index through each array and use <B>const_cast</B> to cast each
element to non-<B>const</B> and non-<B>volatile</B>, respectively, and assign a
value to each
element.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
function that takes a pointer to an array of <B>double</B> and a value
indicating the size of that array. The function should print each element in the
array. Now create an array of <B>double</B> and initialize each element to zero,
then use your function to print the array. Next use <B>reinterpret_cast</B> to
cast the starting address of your array to an <B>unsigned char*</B>, and set
each byte of the array to 1 (hint: you&#8217;ll need to use <B>sizeof</B> to
calculate the number of bytes in a <B>double</B>). Now use your array-printing
function to print the results. Why do you think each element was not set to the
value
1.0?</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">(Challenging)
Modify <B>FloatingAsBinary.cpp</B> so that it prints out each part of the
<B>double</B> as a separate group of bits. You&#8217;ll have to replace the
calls to <B>printBinary(&#160;)</B> with your own specialized code (which you
can derive from <B>printBinary(&#160;)</B>) in<B> </B>order to do this, and
you&#8217;ll also have to look up and understand the floating-point format along
with the byte ordering for your compiler (this is the challenging
part).</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create a
makefile that not only compiles <B>YourPets1.cpp</B> and <B>YourPets2.cpp</B>
(for your particular compiler) but also executes both programs as part of the
default target behavior. Make sure you use suffix
rules.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>StringizingExpressions.cpp</B> so that <B>P(A)</B> is conditionally
<B>#ifdef</B>ed to allow the debugging code to be automatically stripped out by
setting a command-line flag. You will need to consult your compiler&#8217;s
documentation to see how to define and undefine preprocessor values on the
compiler command
line.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Define a
function that takes a <B>double</B> argument and returns an <B>int</B>. Create
and initialize a pointer to this function, and call the function through your
pointer.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Declare a
pointer to a function taking an <B>int</B> argument and returning a pointer to a
function that takes a <B>char </B>argument and returns a
<B>float</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Modify
<B>FunctionTable.cpp</B> so that each function returns a <B>string</B> (instead
of printing out a message) and so that this value is printed inside of
<B>main(&#160;)</B>.</FONT><LI><FONT FACE="Verdana">	</FONT><FONT FACE="Georgia">Create
a <B>makefile</B> for one of the previous exercises (of your choice) that allows
you to type <B>make</B> for a production build of the program, and <B>make
debug</B> for a build of the program including debugging
information.</FONT><A NAME="_Toc465903780"></A><A NAME="_Toc465909181"></A><A NAME="_Toc465909594"></A><A NAME="_Toc466014505"></A><A NAME="_Toc466073415"></A><A NAME="_Toc466083216"></A><A NAME="_Toc468608022"></A><A NAME="_Toc468771343"></A><A NAME="_Toc469811346"></A><A NAME="_Toc469821231"></A><A NAME="_Toc469821647"></A><A NAME="_Toc469825328"></A><A NAME="_Toc469874233"></A><A NAME="_Toc470615889"></A><A NAME="_Toc470655027"></A><A NAME="_Toc470821011"></A><A NAME="_Toc470821428"></A><A NAME="_Toc470911525"></A><A NAME="_Toc471359006"></A><A NAME="_Toc471489426"></A><A NAME="_Toc471528857"></A><A NAME="_Toc471795013"></A><A NAME="_Toc471965590"></A><A NAME="_Toc472045592"></A><A NAME="_Toc472255796"></A><A NAME="_Toc472654399"></A><A NAME="_Toc472654813"></A></OL><FONT FACE = "Verdana"><H1 ALIGN="LEFT">
</H1></FONT>
<DIV ALIGN="LEFT"><P><FONT FACE="Verdana"><B></B></FONT><BR></P></DIV>
<FONT FACE = "Verdana"><H1 ALIGN="LEFT">
</H1></FONT>



<FONT FACE = "Verdana"><H1 ALIGN="LEFT">
</H1></FONT>
<HR><DIV ALIGN="LEFT"><P><A NAME="fn30" HREF="#fnB30">[30]</A><FONT FACE="Georgia" SIZE=2>
Note that all conventions seem to end after the agreement that some sort of
indentation take place. The feud between styles of code formatting is unending.
See Appendix A for the description of this book&#8217;s coding
style.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn31" HREF="#fnB31">[31]</A><FONT FACE="Georgia" SIZE=2>
Thanks to Kris C. Matson for suggesting this exercise topic.</FONT><BR></P></DIV>
<DIV ALIGN="LEFT"><P><A NAME="fn32" HREF="#fnB32">[32]</A><FONT FACE="Georgia" SIZE=2>
Unless you take the very strict approach that &#8220;all argument passing in
C/C++ is by value, and the &#8216;value&#8217; of an array is what is produced
by the array identifier: it&#8217;s address.&#8221; This can be seen as true
from the assembly-language standpoint, but I don&#8217;t think it helps when
trying to work with higher-level concepts. The addition of references in C++
makes the &#8220;all passing is by value&#8221; argument more confusing, to the
point where I feel it&#8217;s more helpful to think in terms of &#8220;passing
by value&#8221; vs. &#8220;passing addresses.&#8221;</FONT><BR></P></DIV>

<DIV ALIGN="CENTER">
    <FONT FACE="Verdana" size = "-1">
     [ <a href="Chapter02.html">Previous Chapter</a> ] 
    [ <a href="Contents.html">Table of Contents</a> ] 
    [ <a href="DocIndex.html">Index</a> ]
     [ <a href="Chapter04.html">Next Chapter</a> ] 
    </FONT>
    <BR>
 Last Update:02/01/2000</P></DIV>

</BODY>

</HTML>
