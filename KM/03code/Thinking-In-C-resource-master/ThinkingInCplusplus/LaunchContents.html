<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<!--
This document was converted from RTF source: 
By rtftohtml 4.19
See http://www.sunpack.com/RTF
Filename:TIC2Vone.rtf
Application Directory:c:\TOOLS\RTF2HTML\
Subject:
Author:Bruce Eckel
Operator:Bruce Eckel
Document Comments:
Version Comments:
Comments:
Keywords:
Translation Date:02/01/2000
Translation Time:14:47:56
Translation Platform:Win32
Number of Output files:22
This File:LaunchContents.html
SplitDepth=1
SkipNavPanel=1
SkipLeadingToc=1
SkipTrailingToc=1
GenContents=1
GenFrames=1
GenIndex=1
-->
<HEAD lang="en"><META http-equiv="Content-Type" content="text/html">
<TITLE>Thinking in C++, 2nd ed. Volume 1 - Contents</TITLE><BASE  TARGET="RightFrame">

</HEAD>

<BODY  BGCOLOR="#FFFFFF"><FONT FACE="Verdana">
<A HREF="Frontmatter.html">Front Pages</A><BR>

<A HREF="Preface.html">          Preface</A><BR>
<UL>
<A HREF="Preface.html#Heading2">What&#8217;s new in the second edition</A><BR>
<UL>
<A HREF="Preface.html#Heading3">What&#8217;s in Volume 2 of this book</A><BR>
<A HREF="Preface.html#Heading4">How to get Volume 2</A><BR>
</UL>
<A HREF="Preface.html#Heading5">Prerequisites</A><BR>
<A HREF="Preface.html#Heading6">Learning C++</A><BR>
<A HREF="Preface.html#Heading7">Goals</A><BR>
<A HREF="Preface.html#Heading8">Chapters</A><BR>
<A HREF="Preface.html#Heading9">Exercises</A><BR>
<UL>
<A HREF="Preface.html#Heading10">Exercise solutions</A><BR>
</UL>
<A HREF="Preface.html#Heading11">Source code</A><BR>
<A HREF="Preface.html#Heading12">Language standards</A><BR>
<UL>
<A HREF="Preface.html#Heading13">Language support</A><BR>
</UL>
<A HREF="Preface.html#Heading14">The book&#8217;s CD ROM</A><BR>
<A HREF="Preface.html#Heading15">CD ROMs, seminars, and consulting</A><BR>
<A HREF="Preface.html#Heading16">Errors</A><BR>
<A HREF="Preface.html#Heading17">About the cover</A><BR>
<A HREF="Preface.html#Heading18">Book design and production</A><BR>
<A HREF="Preface.html#Heading19">Acknowledgements</A><BR>
</UL>
<A HREF="Chapter01.html">1: Introduction to Objects</A><BR>
<UL>
<A HREF="Chapter01.html#Heading21">The progress of abstraction</A><BR>
<A HREF="Chapter01.html#Heading22">An object has an interface</A><BR>
<A HREF="Chapter01.html#Heading23">The hidden implementation</A><BR>
<A HREF="Chapter01.html#Heading24">Reusing the implementation</A><BR>
<A HREF="Chapter01.html#Heading25">Inheritance: reusing the interface</A><BR>
<UL>
<A HREF="Chapter01.html#Heading26">Is-a vs. is-like-a relationships</A><BR>
</UL>
<A HREF="Chapter01.html#Heading27">Interchangeable objects  with polymorphism</A><BR>
<A HREF="Chapter01.html#Heading28">Creating and destroying objects</A><BR>
<A HREF="Chapter01.html#Heading29">Exception handling:  dealing with errors</A><BR>
<A HREF="Chapter01.html#Heading30">Analysis and design</A><BR>
<UL>
<A HREF="Chapter01.html#Heading31">Phase 0: Make a plan</A><BR>
<UL>
<A HREF="Chapter01.html#Heading32">The mission statement</A><BR>
</UL>
<A HREF="Chapter01.html#Heading33">Phase 1: What are we making?</A><BR>
<A HREF="Chapter01.html#Heading34">Phase 2: How will we build it?</A><BR>
<UL>
<A HREF="Chapter01.html#Heading35">Five stages of object design</A><BR>
<A HREF="Chapter01.html#Heading36">Guidelines for object development</A><BR>
</UL>
<A HREF="Chapter01.html#Heading37">Phase 3: Build the core</A><BR>
<A HREF="Chapter01.html#Heading38">Phase 4: Iterate the use cases</A><BR>
<A HREF="Chapter01.html#Heading39">Phase 5: Evolution</A><BR>
<A HREF="Chapter01.html#Heading40">Plans pay off</A><BR>
</UL>
<A HREF="Chapter01.html#Heading41">Extreme programming</A><BR>
<UL>
<A HREF="Chapter01.html#Heading42">Write tests first</A><BR>
<A HREF="Chapter01.html#Heading43">Pair programming</A><BR>
</UL>
<A HREF="Chapter01.html#Heading44">Why C++ succeeds</A><BR>
<UL>
<A HREF="Chapter01.html#Heading45">A better C</A><BR>
<A HREF="Chapter01.html#Heading46">You&#8217;re already on the learning curve</A><BR>
<A HREF="Chapter01.html#Heading47">Efficiency</A><BR>
<A HREF="Chapter01.html#Heading48">Systems are easier  to express and understand</A><BR>
<A HREF="Chapter01.html#Heading49">Maximal leverage with libraries</A><BR>
<A HREF="Chapter01.html#Heading50">Source-code reuse with templates</A><BR>
<A HREF="Chapter01.html#Heading51">Error handling</A><BR>
<A HREF="Chapter01.html#Heading52">Programming in the large</A><BR>
</UL>
<A HREF="Chapter01.html#Heading53">Strategies for transition</A><BR>
<UL>
<A HREF="Chapter01.html#Heading54">Guidelines</A><BR>
<UL>
<A HREF="Chapter01.html#Heading55">1. Training</A><BR>
<A HREF="Chapter01.html#Heading56">2. Low-risk project</A><BR>
<A HREF="Chapter01.html#Heading57">3. Model from success</A><BR>
<A HREF="Chapter01.html#Heading58">4. Use existing class libraries</A><BR>
<A HREF="Chapter01.html#Heading59">5. Don&#8217;t rewrite existing code in C++</A><BR>
</UL>
<A HREF="Chapter01.html#Heading60">Management obstacles</A><BR>
<UL>
<A HREF="Chapter01.html#Heading61">Startup costs</A><BR>
<A HREF="Chapter01.html#Heading62">Performance issues</A><BR>
<A HREF="Chapter01.html#Heading63">Common design errors</A><BR>
</UL>
</UL>
<A HREF="Chapter01.html#Heading64">Summary</A><BR>
</UL>
<A HREF="Chapter02.html">2: Making &amp; Using Objects </A><BR>
<UL>
<A HREF="Chapter02.html#Heading66">The process of language translation</A><BR>
<UL>
<A HREF="Chapter02.html#Heading67">Interpreters</A><BR>
<A HREF="Chapter02.html#Heading68">Compilers</A><BR>
<A HREF="Chapter02.html#Heading69">The compilation process</A><BR>
<UL>
<A HREF="Chapter02.html#Heading70">Static type checking</A><BR>
</UL>
</UL>
<A HREF="Chapter02.html#Heading71">Tools for separate compilation</A><BR>
<UL>
<A HREF="Chapter02.html#Heading72">Declarations vs. definitions</A><BR>
<UL>
<A HREF="Chapter02.html#Heading73">Function declaration syntax</A><BR>
<A HREF="Chapter02.html#Heading74">A gotcha</A><BR>
<A HREF="Chapter02.html#Heading75">Function definitions</A><BR>
<A HREF="Chapter02.html#Heading76">Variable declaration syntax</A><BR>
<A HREF="Chapter02.html#Heading77">Including headers </A><BR>
<A HREF="Chapter02.html#Heading78">Standard C++ include format</A><BR>
</UL>
<A HREF="Chapter02.html#Heading79">Linking </A><BR>
<A HREF="Chapter02.html#Heading80">Using libraries </A><BR>
<UL>
<A HREF="Chapter02.html#Heading81">How the linker searches a library </A><BR>
<A HREF="Chapter02.html#Heading82">Secret additions</A><BR>
<A HREF="Chapter02.html#Heading83">Using plain C libraries </A><BR>
</UL>
</UL>
<A HREF="Chapter02.html#Heading84">Your first C++ program</A><BR>
<UL>
<A HREF="Chapter02.html#Heading85">Using the iostreams class </A><BR>
<A HREF="Chapter02.html#Heading86">Namespaces</A><BR>
<A HREF="Chapter02.html#Heading87">Fundamentals of program structure </A><BR>
<A HREF="Chapter02.html#Heading88">"Hello, world!"</A><BR>
<A HREF="Chapter02.html#Heading89">Running the compiler </A><BR>
</UL>
<A HREF="Chapter02.html#Heading90">More about iostreams </A><BR>
<UL>
<A HREF="Chapter02.html#Heading91">Character array concatenation</A><BR>
<A HREF="Chapter02.html#Heading92">Reading input</A><BR>
<A HREF="Chapter02.html#Heading93">Calling other programs</A><BR>
</UL>
<A HREF="Chapter02.html#Heading94">Introducing strings</A><BR>
<A HREF="Chapter02.html#Heading95">Reading and writing files</A><BR>
<A HREF="Chapter02.html#Heading96">Introducing vector</A><BR>
<A HREF="Chapter02.html#Heading97">Summary</A><BR>
<A HREF="Chapter02.html#Heading98">Exercises</A><BR>
</UL>
<A HREF="Chapter03.html">3: The C in C++</A><BR>
<UL>
<A HREF="Chapter03.html#Heading100">Creating functions</A><BR>
<UL>
<A HREF="Chapter03.html#Heading101">Function return values</A><BR>
<A HREF="Chapter03.html#Heading102">Using the C function library</A><BR>
<A HREF="Chapter03.html#Heading103">Creating your own libraries with the librarian </A><BR>
</UL>
<A HREF="Chapter03.html#Heading104">Controlling execution </A><BR>
<UL>
<A HREF="Chapter03.html#Heading105">True and false</A><BR>
<A HREF="Chapter03.html#Heading106">if-else</A><BR>
<A HREF="Chapter03.html#Heading107">while</A><BR>
<A HREF="Chapter03.html#Heading108">do-while</A><BR>
<A HREF="Chapter03.html#Heading109">for</A><BR>
<A HREF="Chapter03.html#Heading110">The break and continue keywords </A><BR>
<A HREF="Chapter03.html#Heading111">switch</A><BR>
<A HREF="Chapter03.html#Heading112">Using and misusing goto</A><BR>
<A HREF="Chapter03.html#Heading113">Recursion</A><BR>
</UL>
<A HREF="Chapter03.html#Heading114"> Introduction to operators</A><BR>
<UL>
<A HREF="Chapter03.html#Heading115">Precedence</A><BR>
<A HREF="Chapter03.html#Heading116">Auto increment and decrement</A><BR>
</UL>
<A HREF="Chapter03.html#Heading117">Introduction to data types</A><BR>
<UL>
<A HREF="Chapter03.html#Heading118">Basic built-in types</A><BR>
<A HREF="Chapter03.html#Heading119">bool, true, &amp; false</A><BR>
<A HREF="Chapter03.html#Heading120">Specifiers</A><BR>
<A HREF="Chapter03.html#Heading121">Introduction to pointers</A><BR>
<A HREF="Chapter03.html#Heading122">Modifying the outside object</A><BR>
<A HREF="Chapter03.html#Heading123">Introduction to C++ references</A><BR>
<A HREF="Chapter03.html#Heading124">Pointers and references as modifiers</A><BR>
</UL>
<A HREF="Chapter03.html#Heading125">Scoping</A><BR>
<UL>
<A HREF="Chapter03.html#Heading126">Defining variables on the fly</A><BR>
</UL>
<A HREF="Chapter03.html#Heading127">Specifying storage allocation</A><BR>
<UL>
<A HREF="Chapter03.html#Heading128">Global variables</A><BR>
<A HREF="Chapter03.html#Heading129">Local variables</A><BR>
<UL>
<A HREF="Chapter03.html#Heading130">Register variables</A><BR>
</UL>
<A HREF="Chapter03.html#Heading131">static</A><BR>
<A HREF="Chapter03.html#Heading132">extern</A><BR>
<UL>
<A HREF="Chapter03.html#Heading133">Linkage</A><BR>
</UL>
<A HREF="Chapter03.html#Heading134">Constants</A><BR>
<UL>
<A HREF="Chapter03.html#Heading135">Constant values</A><BR>
</UL>
<A HREF="Chapter03.html#Heading136">volatile</A><BR>
</UL>
<A HREF="Chapter03.html#Heading137">Operators and their use</A><BR>
<UL>
<A HREF="Chapter03.html#Heading138">Assignment</A><BR>
<A HREF="Chapter03.html#Heading139">Mathematical operators</A><BR>
<UL>
<A HREF="Chapter03.html#Heading140">Introduction to preprocessor macros</A><BR>
</UL>
<A HREF="Chapter03.html#Heading141">Relational operators</A><BR>
<A HREF="Chapter03.html#Heading142">Logical operators</A><BR>
<A HREF="Chapter03.html#Heading143">Bitwise operators</A><BR>
<A HREF="Chapter03.html#Heading144">Shift operators</A><BR>
<A HREF="Chapter03.html#Heading145">Unary operators</A><BR>
<A HREF="Chapter03.html#Heading146">The ternary operator</A><BR>
<A HREF="Chapter03.html#Heading147">The comma operator</A><BR>
<A HREF="Chapter03.html#Heading148">Common pitfalls when using operators</A><BR>
<A HREF="Chapter03.html#Heading149">Casting operators</A><BR>
<A HREF="Chapter03.html#Heading150">C++ explicit casts</A><BR>
<UL>
<A HREF="Chapter03.html#Heading151">static_cast</A><BR>
<A HREF="Chapter03.html#Heading152">const_cast</A><BR>
<A HREF="Chapter03.html#Heading153">reinterpret_cast</A><BR>
</UL>
<A HREF="Chapter03.html#Heading154">sizeof &#8211; an operator by itself </A><BR>
<A HREF="Chapter03.html#Heading155">The asm keyword</A><BR>
<A HREF="Chapter03.html#Heading156">Explicit operators</A><BR>
</UL>
<A HREF="Chapter03.html#Heading157">Composite type creation</A><BR>
<UL>
<A HREF="Chapter03.html#Heading158">Aliasing names with typedef</A><BR>
<A HREF="Chapter03.html#Heading159">Combining variables with struct</A><BR>
<UL>
<A HREF="Chapter03.html#Heading160">Pointers and structs</A><BR>
</UL>
<A HREF="Chapter03.html#Heading161">Clarifying programs with enum</A><BR>
<UL>
<A HREF="Chapter03.html#Heading162">Type checking for enumerations</A><BR>
</UL>
<A HREF="Chapter03.html#Heading163">Saving memory with union </A><BR>
<A HREF="Chapter03.html#Heading164">Arrays</A><BR>
<UL>
<A HREF="Chapter03.html#Heading165">Pointers and arrays</A><BR>
<A HREF="Chapter03.html#Heading166">Exploring floating-point format</A><BR>
<A HREF="Chapter03.html#Heading167">Pointer arithmetic</A><BR>
</UL>
</UL>
<A HREF="Chapter03.html#Heading168">Debugging hints</A><BR>
<UL>
<A HREF="Chapter03.html#Heading169">Debugging flags</A><BR>
<UL>
<A HREF="Chapter03.html#Heading170">Preprocessor debugging flags</A><BR>
<A HREF="Chapter03.html#Heading171">Runtime debugging flags</A><BR>
</UL>
<A HREF="Chapter03.html#Heading172">Turning variables and expressions into strings</A><BR>
<A HREF="Chapter03.html#Heading173">The C assert(&#160;) macro</A><BR>
</UL>
<A HREF="Chapter03.html#Heading174">Function addresses</A><BR>
<UL>
<A HREF="Chapter03.html#Heading175">Defining a function pointer</A><BR>
<A HREF="Chapter03.html#Heading176">Complicated declarations &amp; definitions</A><BR>
<A HREF="Chapter03.html#Heading177">Using a function pointer</A><BR>
<A HREF="Chapter03.html#Heading178">Arrays of pointers to functions</A><BR>
</UL>
<A HREF="Chapter03.html#Heading179">Make: managing separate compilation</A><BR>
<UL>
<A HREF="Chapter03.html#Heading180">Make activities</A><BR>
<UL>
<A HREF="Chapter03.html#Heading181">Macros</A><BR>
<A HREF="Chapter03.html#Heading182">Suffix Rules</A><BR>
<A HREF="Chapter03.html#Heading183">Default targets</A><BR>
</UL>
<A HREF="Chapter03.html#Heading184">Makefiles in this book</A><BR>
<A HREF="Chapter03.html#Heading185">An example makefile</A><BR>
</UL>
<A HREF="Chapter03.html#Heading186">Summary</A><BR>
<A HREF="Chapter03.html#Heading187">Exercises</A><BR>
</UL>
<A HREF="Chapter04.html">4: Data Abstraction</A><BR>
<UL>
<A HREF="Chapter04.html#Heading189">A tiny C-like library</A><BR>
<UL>
<A HREF="Chapter04.html#Heading190">Dynamic storage allocation</A><BR>
<A HREF="Chapter04.html#Heading191">Bad guesses</A><BR>
</UL>
<A HREF="Chapter04.html#Heading192">What's wrong?</A><BR>
<A HREF="Chapter04.html#Heading193">The basic object</A><BR>
<A HREF="Chapter04.html#Heading194">What's an object?</A><BR>
<A HREF="Chapter04.html#Heading195">Abstract data typing</A><BR>
<A HREF="Chapter04.html#Heading196">Object details</A><BR>
<A HREF="Chapter04.html#Heading197">Header file etiquette</A><BR>
<UL>
<A HREF="Chapter04.html#Heading198">Importance of header files</A><BR>
<A HREF="Chapter04.html#Heading199">The multiple-declaration problem</A><BR>
<A HREF="Chapter04.html#Heading200">The preprocessor directives  #define, #ifdef, and #endif</A><BR>
<A HREF="Chapter04.html#Heading201">A standard for header files</A><BR>
<A HREF="Chapter04.html#Heading202">Namespaces in headers</A><BR>
<A HREF="Chapter04.html#Heading203">Using headers in projects</A><BR>
</UL>
<A HREF="Chapter04.html#Heading204">Nested structures</A><BR>
<UL>
<A HREF="Chapter04.html#Heading205">Global scope resolution</A><BR>
</UL>
<A HREF="Chapter04.html#Heading206">Summary</A><BR>
<A HREF="Chapter04.html#Heading207">Exercises</A><BR>
</UL>
<A HREF="Chapter05.html">5: Hiding the Implementation</A><BR>
<UL>
<A HREF="Chapter05.html#Heading209">Setting limits</A><BR>
<A HREF="Chapter05.html#Heading210">C++ access control</A><BR>
<UL>
<A HREF="Chapter05.html#Heading211">protected</A><BR>
</UL>
<A HREF="Chapter05.html#Heading212">Friends</A><BR>
<UL>
<A HREF="Chapter05.html#Heading213">Nested friends</A><BR>
<A HREF="Chapter05.html#Heading214">Is it pure?</A><BR>
</UL>
<A HREF="Chapter05.html#Heading215">Object layout</A><BR>
<A HREF="Chapter05.html#Heading216">The class</A><BR>
<UL>
<A HREF="Chapter05.html#Heading217">Modifying Stash to use access control</A><BR>
<A HREF="Chapter05.html#Heading218">Modifying Stack to use access control</A><BR>
</UL>
<A HREF="Chapter05.html#Heading219">Handle classes</A><BR>
<UL>
<A HREF="Chapter05.html#Heading220">Hiding the implementation</A><BR>
<A HREF="Chapter05.html#Heading221">Reducing recompilation</A><BR>
</UL>
<A HREF="Chapter05.html#Heading222">Summary</A><BR>
<A HREF="Chapter05.html#Heading223">Exercises</A><BR>
</UL>
<A HREF="Chapter06.html">6: Initialization &amp; Cleanup</A><BR>
<UL>
<A HREF="Chapter06.html#Heading225">Guaranteed initialization with the constructor</A><BR>
<A HREF="Chapter06.html#Heading226">Guaranteed cleanup with the destructor</A><BR>
<A HREF="Chapter06.html#Heading227">Elimination of the definition block</A><BR>
<UL>
<A HREF="Chapter06.html#Heading228">for loops</A><BR>
<A HREF="Chapter06.html#Heading229">Storage allocation</A><BR>
</UL>
<A HREF="Chapter06.html#Heading230">Stash with constructors and destructors</A><BR>
<A HREF="Chapter06.html#Heading231">Stack with constructors &amp; destructors</A><BR>
<A HREF="Chapter06.html#Heading232">Aggregate initialization</A><BR>
<A HREF="Chapter06.html#Heading233">Default constructors</A><BR>
<A HREF="Chapter06.html#Heading234">Summary</A><BR>
<A HREF="Chapter06.html#Heading235">Exercises</A><BR>
</UL>
<A HREF="Chapter07.html">7: Function Overloading &amp; Default Arguments</A><BR>
<UL>
<A HREF="Chapter07.html#Heading237">More name decoration</A><BR>
<UL>
<A HREF="Chapter07.html#Heading238">Overloading on return values</A><BR>
<A HREF="Chapter07.html#Heading239">Type-safe linkage</A><BR>
</UL>
<A HREF="Chapter07.html#Heading240">Overloading example</A><BR>
<A HREF="Chapter07.html#Heading241">unions</A><BR>
<A HREF="Chapter07.html#Heading242">Default arguments</A><BR>
<UL>
<A HREF="Chapter07.html#Heading243">Placeholder arguments</A><BR>
</UL>
<A HREF="Chapter07.html#Heading244">Choosing overloading vs. default arguments</A><BR>
<A HREF="Chapter07.html#Heading245">Summary</A><BR>
<A HREF="Chapter07.html#Heading246">Exercises</A><BR>
</UL>
<A HREF="Chapter08.html">8: Constants</A><BR>
<UL>
<A HREF="Chapter08.html#Heading248">Value substitution</A><BR>
<UL>
<A HREF="Chapter08.html#Heading249">const in header files</A><BR>
<A HREF="Chapter08.html#Heading250">Safety consts</A><BR>
<A HREF="Chapter08.html#Heading251">Aggregates</A><BR>
<A HREF="Chapter08.html#Heading252">Differences with C</A><BR>
</UL>
<A HREF="Chapter08.html#Heading253">Pointers</A><BR>
<UL>
<A HREF="Chapter08.html#Heading254">Pointer to const</A><BR>
<A HREF="Chapter08.html#Heading255">const pointer</A><BR>
<UL>
<A HREF="Chapter08.html#Heading256">Formatting</A><BR>
</UL>
<A HREF="Chapter08.html#Heading257">Assignment and type checking</A><BR>
<UL>
<A HREF="Chapter08.html#Heading258">Character array literals</A><BR>
</UL>
</UL>
<A HREF="Chapter08.html#Heading259">Function arguments  &amp; return values</A><BR>
<UL>
<A HREF="Chapter08.html#Heading260">Passing by const value</A><BR>
<A HREF="Chapter08.html#Heading261">Returning by const value</A><BR>
<UL>
<A HREF="Chapter08.html#Heading262">Temporaries</A><BR>
</UL>
<A HREF="Chapter08.html#Heading263">Passing and returning addresses</A><BR>
<UL>
<A HREF="Chapter08.html#Heading264">Standard argument passing</A><BR>
</UL>
</UL>
<A HREF="Chapter08.html#Heading265">Classes</A><BR>
<UL>
<A HREF="Chapter08.html#Heading266">const in classes</A><BR>
<UL>
<A HREF="Chapter08.html#Heading267">The constructor initializer list</A><BR>
<A HREF="Chapter08.html#Heading268">&#8220;Constructors&#8221; for built-in types</A><BR>
</UL>
<A HREF="Chapter08.html#Heading269">Compile-time constants in classes</A><BR>
<UL>
<A HREF="Chapter08.html#Heading270">The &#8220;enum hack&#8221; in old code</A><BR>
</UL>
<A HREF="Chapter08.html#Heading271">const objects &amp; member functions</A><BR>
<UL>
<A HREF="Chapter08.html#Heading272">mutable: bitwise vs. logical const</A><BR>
<A HREF="Chapter08.html#Heading273">ROMability</A><BR>
</UL>
</UL>
<A HREF="Chapter08.html#Heading274">volatile</A><BR>
<A HREF="Chapter08.html#Heading275">Summary</A><BR>
<A HREF="Chapter08.html#Heading276">Exercises</A><BR>
</UL>
<A HREF="Chapter09.html">9: Inline Functions</A><BR>
<UL>
<A HREF="Chapter09.html#Heading278">Preprocessor pitfalls</A><BR>
<UL>
<A HREF="Chapter09.html#Heading279">Macros and access</A><BR>
</UL>
<A HREF="Chapter09.html#Heading280">Inline functions</A><BR>
<UL>
<A HREF="Chapter09.html#Heading281">Inlines inside classes</A><BR>
<A HREF="Chapter09.html#Heading282">Access functions</A><BR>
<UL>
<A HREF="Chapter09.html#Heading283">Accessors and mutators</A><BR>
</UL>
</UL>
<A HREF="Chapter09.html#Heading284">Stash &amp; Stack with inlines</A><BR>
<A HREF="Chapter09.html#Heading285">Inlines &amp; the compiler</A><BR>
<UL>
<A HREF="Chapter09.html#Heading286">Limitations</A><BR>
<A HREF="Chapter09.html#Heading287">Forward references</A><BR>
<A HREF="Chapter09.html#Heading288">Hidden activities in constructors &amp; destructors</A><BR>
</UL>
<A HREF="Chapter09.html#Heading289">Reducing clutter</A><BR>
<A HREF="Chapter09.html#Heading290">More preprocessor features</A><BR>
<UL>
<A HREF="Chapter09.html#Heading291">Token pasting</A><BR>
</UL>
<A HREF="Chapter09.html#Heading292">Improved error checking</A><BR>
<A HREF="Chapter09.html#Heading293">Summary</A><BR>
<A HREF="Chapter09.html#Heading294">Exercises</A><BR>
</UL>
<A HREF="Chapter10.html">10: Name Control</A><BR>
<UL>
<A HREF="Chapter10.html#Heading296">Static elements from C</A><BR>
<UL>
<A HREF="Chapter10.html#Heading297">static variables inside functions</A><BR>
<UL>
<A HREF="Chapter10.html#Heading298">static class objects inside functions</A><BR>
<A HREF="Chapter10.html#Heading299">Static object destructors</A><BR>
</UL>
<A HREF="Chapter10.html#Heading300">Controlling linkage</A><BR>
<UL>
<A HREF="Chapter10.html#Heading301">Confusion</A><BR>
</UL>
<A HREF="Chapter10.html#Heading302">Other storage class specifiers</A><BR>
</UL>
<A HREF="Chapter10.html#Heading303">Namespaces</A><BR>
<UL>
<A HREF="Chapter10.html#Heading304">Creating a namespace</A><BR>
<UL>
<A HREF="Chapter10.html#Heading305">Unnamed namespaces</A><BR>
<A HREF="Chapter10.html#Heading306">Friends</A><BR>
</UL>
<A HREF="Chapter10.html#Heading307">Using a namespace</A><BR>
<UL>
<A HREF="Chapter10.html#Heading308">Scope resolution</A><BR>
<A HREF="Chapter10.html#Heading309">The using directive</A><BR>
<A HREF="Chapter10.html#Heading310">The using declaration</A><BR>
</UL>
<A HREF="Chapter10.html#Heading311">The use of namespaces</A><BR>
</UL>
<A HREF="Chapter10.html#Heading312">Static members in C++</A><BR>
<UL>
<A HREF="Chapter10.html#Heading313">Defining storage for static data members</A><BR>
<UL>
<A HREF="Chapter10.html#Heading314">static array initialization</A><BR>
</UL>
<A HREF="Chapter10.html#Heading315">Nested and local classes</A><BR>
<A HREF="Chapter10.html#Heading316">static member functions</A><BR>
</UL>
<A HREF="Chapter10.html#Heading317">Static initialization dependency</A><BR>
<UL>
<A HREF="Chapter10.html#Heading318">What to do</A><BR>
<UL>
<A HREF="Chapter10.html#Heading319">Technique one</A><BR>
<A HREF="Chapter10.html#Heading320">Technique two</A><BR>
</UL>
</UL>
<A HREF="Chapter10.html#Heading321">Alternate linkage specifications</A><BR>
<A HREF="Chapter10.html#Heading322">Summary</A><BR>
<A HREF="Chapter10.html#Heading323">Exercises</A><BR>
</UL>
<A HREF="Chapter11.html">11: References &amp;  the Copy-Constructor</A><BR>
<UL>
<A HREF="Chapter11.html#Heading325">Pointers in C++</A><BR>
<A HREF="Chapter11.html#Heading326">References in C++</A><BR>
<UL>
<A HREF="Chapter11.html#Heading327">References in functions</A><BR>
<UL>
<A HREF="Chapter11.html#Heading328">const references</A><BR>
<A HREF="Chapter11.html#Heading329">Pointer references</A><BR>
</UL>
<A HREF="Chapter11.html#Heading330">Argument-passing guidelines</A><BR>
</UL>
<A HREF="Chapter11.html#Heading331">The copy-constructor</A><BR>
<UL>
<A HREF="Chapter11.html#Heading332">Passing &amp; returning by value</A><BR>
<UL>
<A HREF="Chapter11.html#Heading333">Passing &amp; returning large objects</A><BR>
<A HREF="Chapter11.html#Heading334">Function-call stack frame</A><BR>
<A HREF="Chapter11.html#Heading335">Re-entrancy</A><BR>
<A HREF="Chapter11.html#Heading336">Bitcopy versus initialization</A><BR>
</UL>
<A HREF="Chapter11.html#Heading337">Copy-construction</A><BR>
<UL>
<A HREF="Chapter11.html#Heading338">Temporary objects</A><BR>
</UL>
<A HREF="Chapter11.html#Heading339">Default copy-constructor</A><BR>
<A HREF="Chapter11.html#Heading340">Alternatives to copy-construction</A><BR>
<UL>
<A HREF="Chapter11.html#Heading341">Preventing pass-by-value</A><BR>
<A HREF="Chapter11.html#Heading342">Functions that modify outside objects</A><BR>
</UL>
</UL>
<A HREF="Chapter11.html#Heading343">Pointers to members</A><BR>
<UL>
<A HREF="Chapter11.html#Heading344">Functions</A><BR>
<UL>
<A HREF="Chapter11.html#Heading345">An example</A><BR>
</UL>
</UL>
<A HREF="Chapter11.html#Heading346">Summary</A><BR>
<A HREF="Chapter11.html#Heading347">Exercises</A><BR>
</UL>
<A HREF="Chapter12.html">12: Operator Overloading</A><BR>
<UL>
<A HREF="Chapter12.html#Heading349">Warning &amp; reassurance</A><BR>
<A HREF="Chapter12.html#Heading350">Syntax</A><BR>
<A HREF="Chapter12.html#Heading351">Overloadable operators</A><BR>
<UL>
<A HREF="Chapter12.html#Heading352">Unary operators</A><BR>
<UL>
<A HREF="Chapter12.html#Heading353">Increment &amp; decrement</A><BR>
</UL>
<A HREF="Chapter12.html#Heading354">Binary operators</A><BR>
<A HREF="Chapter12.html#Heading355">Arguments &amp; return values</A><BR>
<UL>
<A HREF="Chapter12.html#Heading356">Return by value as const</A><BR>
<A HREF="Chapter12.html#Heading357">The return optimization</A><BR>
</UL>
<A HREF="Chapter12.html#Heading358">Unusual operators</A><BR>
<UL>
<A HREF="Chapter12.html#Heading359">Operator comma</A><BR>
<A HREF="Chapter12.html#Heading360">Operator-&gt;</A><BR>
<A HREF="Chapter12.html#Heading361">A nested iterator</A><BR>
<A HREF="Chapter12.html#Heading362">Operator-&gt;*</A><BR>
</UL>
<A HREF="Chapter12.html#Heading363">Operators you can&#8217;t overload</A><BR>
</UL>
<A HREF="Chapter12.html#Heading364">Non-member operators</A><BR>
<UL>
<A HREF="Chapter12.html#Heading365">Basic guidelines</A><BR>
</UL>
<A HREF="Chapter12.html#Heading366">Overloading assignment</A><BR>
<UL>
<A HREF="Chapter12.html#Heading367">Behavior of operator=</A><BR>
<UL>
<A HREF="Chapter12.html#Heading368">Pointers in classes</A><BR>
<A HREF="Chapter12.html#Heading369">Reference Counting</A><BR>
<A HREF="Chapter12.html#Heading370">Automatic operator= creation</A><BR>
</UL>
</UL>
<A HREF="Chapter12.html#Heading371">Automatic type conversion</A><BR>
<UL>
<A HREF="Chapter12.html#Heading372">Constructor conversion</A><BR>
<UL>
<A HREF="Chapter12.html#Heading373">Preventing constructor conversion</A><BR>
</UL>
<A HREF="Chapter12.html#Heading374">Operator conversion</A><BR>
<UL>
<A HREF="Chapter12.html#Heading375">Reflexivity</A><BR>
</UL>
<A HREF="Chapter12.html#Heading376">Type conversion example</A><BR>
<A HREF="Chapter12.html#Heading377">Pitfalls in automatic type conversion</A><BR>
<UL>
<A HREF="Chapter12.html#Heading378">Hidden activities</A><BR>
</UL>
</UL>
<A HREF="Chapter12.html#Heading379">Summary</A><BR>
<A HREF="Chapter12.html#Heading380">Exercises</A><BR>
</UL>
<A HREF="Chapter13.html">13: Dynamic Object Creation</A><BR>
<UL>
<A HREF="Chapter13.html#Heading382">Object creation</A><BR>
<UL>
<A HREF="Chapter13.html#Heading383">C&#8217;s approach to the heap</A><BR>
<A HREF="Chapter13.html#Heading384">operator new</A><BR>
<A HREF="Chapter13.html#Heading385">operator delete</A><BR>
<A HREF="Chapter13.html#Heading386">A simple example</A><BR>
<A HREF="Chapter13.html#Heading387">Memory manager overhead</A><BR>
</UL>
<A HREF="Chapter13.html#Heading388">Early examples redesigned</A><BR>
<UL>
<A HREF="Chapter13.html#Heading389">delete void* is probably a bug</A><BR>
<A HREF="Chapter13.html#Heading390">Cleanup responsibility with pointers</A><BR>
<A HREF="Chapter13.html#Heading391">Stash for pointers</A><BR>
<UL>
<A HREF="Chapter13.html#Heading392">A test</A><BR>
</UL>
</UL>
<A HREF="Chapter13.html#Heading393">new &amp; delete for arrays</A><BR>
<UL>
<A HREF="Chapter13.html#Heading394">Making a pointer more like an array</A><BR>
</UL>
<A HREF="Chapter13.html#Heading395">Running out of storage</A><BR>
<A HREF="Chapter13.html#Heading396">Overloading new &amp; delete</A><BR>
<UL>
<A HREF="Chapter13.html#Heading397">Overloading global new &amp; delete</A><BR>
<A HREF="Chapter13.html#Heading398">Overloading new &amp; delete for a class</A><BR>
<A HREF="Chapter13.html#Heading399">Overloading new &amp; delete for arrays</A><BR>
<A HREF="Chapter13.html#Heading400">Constructor calls</A><BR>
<A HREF="Chapter13.html#Heading401">placement new &amp; delete</A><BR>
</UL>
<A HREF="Chapter13.html#Heading402">Summary</A><BR>
<A HREF="Chapter13.html#Heading403">Exercises</A><BR>
</UL>
<A HREF="Chapter14.html">14: Inheritance &amp; Composition</A><BR>
<UL>
<A HREF="Chapter14.html#Heading405">Composition syntax</A><BR>
<A HREF="Chapter14.html#Heading406">Inheritance syntax</A><BR>
<A HREF="Chapter14.html#Heading407">The constructor initializer list</A><BR>
<UL>
<A HREF="Chapter14.html#Heading408">Member object initialization</A><BR>
<A HREF="Chapter14.html#Heading409">Built-in types in the initializer list</A><BR>
</UL>
<A HREF="Chapter14.html#Heading410">Combining composition &amp; inheritance</A><BR>
<UL>
<A HREF="Chapter14.html#Heading411">Automatic destructor calls</A><BR>
</UL>
<A HREF="Chapter14.html#Heading412">Order of constructor &amp; destructor calls</A><BR>
<A HREF="Chapter14.html#Heading413">Name hiding</A><BR>
<A HREF="Chapter14.html#Heading414">Functions that don&#8217;t automatically inherit</A><BR>
<UL>
<A HREF="Chapter14.html#Heading415">Inheritance and static member functions</A><BR>
</UL>
<A HREF="Chapter14.html#Heading416">Choosing composition vs. inheritance</A><BR>
<UL>
<A HREF="Chapter14.html#Heading417">Subtyping</A><BR>
<A HREF="Chapter14.html#Heading418">private inheritance</A><BR>
<UL>
<A HREF="Chapter14.html#Heading419">Publicizing privately inherited members</A><BR>
</UL>
</UL>
<A HREF="Chapter14.html#Heading420">protected</A><BR>
<UL>
<A HREF="Chapter14.html#Heading421">protected inheritance</A><BR>
</UL>
<A HREF="Chapter14.html#Heading422">Operator overloading &amp; inheritance</A><BR>
<A HREF="Chapter14.html#Heading423">Multiple inheritance</A><BR>
<A HREF="Chapter14.html#Heading424">Incremental development</A><BR>
<A HREF="Chapter14.html#Heading425">Upcasting</A><BR>
<UL>
<A HREF="Chapter14.html#Heading426">Why &#8220;upcasting?&#8221;</A><BR>
<A HREF="Chapter14.html#Heading427">Upcasting and the copy-constructor</A><BR>
<A HREF="Chapter14.html#Heading428">Composition vs. inheritance (revisited)</A><BR>
<A HREF="Chapter14.html#Heading429">Pointer &amp; reference upcasting</A><BR>
<A HREF="Chapter14.html#Heading430">A crisis</A><BR>
</UL>
<A HREF="Chapter14.html#Heading431">Summary</A><BR>
<A HREF="Chapter14.html#Heading432">Exercises</A><BR>
</UL>
<A HREF="Chapter15.html">15: Polymorphism &amp;  Virtual Functions</A><BR>
<UL>
<A HREF="Chapter15.html#Heading434">Evolution of C++ programmers</A><BR>
<A HREF="Chapter15.html#Heading435">Upcasting</A><BR>
<A HREF="Chapter15.html#Heading436">The problem</A><BR>
<UL>
<A HREF="Chapter15.html#Heading437">Function call binding</A><BR>
</UL>
<A HREF="Chapter15.html#Heading438">virtual functions</A><BR>
<UL>
<A HREF="Chapter15.html#Heading439">Extensibility</A><BR>
</UL>
<A HREF="Chapter15.html#Heading440">How C++ implements late binding</A><BR>
<UL>
<A HREF="Chapter15.html#Heading441">Storing type information</A><BR>
<A HREF="Chapter15.html#Heading442">Picturing virtual functions</A><BR>
<A HREF="Chapter15.html#Heading443">Under the hood</A><BR>
<A HREF="Chapter15.html#Heading444">Installing the vpointer</A><BR>
<A HREF="Chapter15.html#Heading445">Objects are different</A><BR>
</UL>
<A HREF="Chapter15.html#Heading446">Why virtual functions?</A><BR>
<A HREF="Chapter15.html#Heading447">Abstract base classes and pure virtual functions</A><BR>
<UL>
<A HREF="Chapter15.html#Heading448">Pure virtual definitions</A><BR>
</UL>
<A HREF="Chapter15.html#Heading449">Inheritance and the VTABLE</A><BR>
<UL>
<A HREF="Chapter15.html#Heading450">Object slicing</A><BR>
</UL>
<A HREF="Chapter15.html#Heading451">Overloading &amp; overriding</A><BR>
<UL>
<A HREF="Chapter15.html#Heading452">Variant return type</A><BR>
</UL>
<A HREF="Chapter15.html#Heading453">virtual functions &amp; constructors</A><BR>
<UL>
<A HREF="Chapter15.html#Heading454">Order of constructor calls</A><BR>
<A HREF="Chapter15.html#Heading455">Behavior of virtual functions inside constructors</A><BR>
</UL>
<A HREF="Chapter15.html#Heading456">Destructors and virtual destructors</A><BR>
<UL>
<A HREF="Chapter15.html#Heading457">Pure virtual destructors</A><BR>
<A HREF="Chapter15.html#Heading458">Virtuals in destructors</A><BR>
<A HREF="Chapter15.html#Heading459">Creating an object-based hierarchy</A><BR>
</UL>
<A HREF="Chapter15.html#Heading460">Operator overloading</A><BR>
<A HREF="Chapter15.html#Heading461">Downcasting</A><BR>
<A HREF="Chapter15.html#Heading462">Summary</A><BR>
<A HREF="Chapter15.html#Heading463">Exercises</A><BR>
</UL>
<A HREF="Chapter16.html">16: Introduction to Templates</A><BR>
<UL>
<A HREF="Chapter16.html#Heading465">Containers</A><BR>
<UL>
<A HREF="Chapter16.html#Heading466">The need for containers</A><BR>
</UL>
<A HREF="Chapter16.html#Heading467">Overview of templates</A><BR>
<UL>
<A HREF="Chapter16.html#Heading468">The template solution</A><BR>
</UL>
<A HREF="Chapter16.html#Heading469">Template syntax</A><BR>
<UL>
<A HREF="Chapter16.html#Heading470">Non-inline function definitions</A><BR>
<UL>
<A HREF="Chapter16.html#Heading471">Header files</A><BR>
</UL>
<A HREF="Chapter16.html#Heading472">IntStack as a template</A><BR>
<A HREF="Chapter16.html#Heading473">Constants in templates</A><BR>
</UL>
<A HREF="Chapter16.html#Heading474">Stack and Stash as templates</A><BR>
<UL>
<A HREF="Chapter16.html#Heading475">Templatized pointer Stash</A><BR>
</UL>
<A HREF="Chapter16.html#Heading476">Turning ownership on and off</A><BR>
<A HREF="Chapter16.html#Heading477">Holding objects by value</A><BR>
<A HREF="Chapter16.html#Heading478">Introducing iterators</A><BR>
<UL>
<A HREF="Chapter16.html#Heading479">Stack with iterators</A><BR>
<A HREF="Chapter16.html#Heading480">PStash with iterators</A><BR>
</UL>
<A HREF="Chapter16.html#Heading481">Why iterators?</A><BR>
<UL>
<A HREF="Chapter16.html#Heading482">Function templates</A><BR>
</UL>
<A HREF="Chapter16.html#Heading483">Summary</A><BR>
<A HREF="Chapter16.html#Heading484">Exercises</A><BR>
</UL>
<A HREF="AppendixA.html">A: Coding Style</A><BR>
<A HREF="AppendixB.html">B: Programming Guidelines</A><BR>
<A HREF="AppendixC.html">C: Recommended Reading</A><BR>
<UL>
<A HREF="AppendixC.html#Heading488">C</A><BR>
<A HREF="AppendixC.html#Heading489">General C++</A><BR>
<UL>
<A HREF="AppendixC.html#Heading490">My own list of books </A><BR>
</UL>
<A HREF="AppendixC.html#Heading491">Depth &amp; dark corners</A><BR>
<A HREF="AppendixC.html#Heading492">Analysis &amp; design</A><BR>
</UL>
<A HREF="DocIndex.html">Index</A><BR>

</BODY>
</HTML>
