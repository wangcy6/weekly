





### 导读



https://shimo.im/mindmaps/rCPHvck6vwXVy3tx



### （老王） 我演示一下查找

 

- 查找元素6



![b+_find_6.gif](https://upload-images.jianshu.io/upload_images/1837968-3e5d567d6e8f61f6.gif?imageMogr2/auto-orient/strip)

- 查找元素12 

![B+_find_12.gif](https://upload-images.jianshu.io/upload_images/1837968-429b1a9ee7112a07.gif?imageMogr2/auto-orient/strip)



- 查找元素17

![B+_find_17.gif](https://upload-images.jianshu.io/upload_images/1837968-518331ffa6987479.gif?imageMogr2/auto-orient/strip)





### （小王）我知道如何查找了



  查询tree_search (k, root) 逻辑 

1. 如果root为null，直接返回查询失败。因为后面没有数据了。
2. 如果是叶子节点，直接查询k。并返回寻找结果。
3. root 如果是非叶子节点。

  循环遍历   如果 k <key1

​       从对应子树 继续寻找tree_search (k, root.1.child) 递归遍历

4. 循环遍历结束。k 大于任何一个key。递归最有一个子树

    tree_search (k, root.last.child)

   

```c++
Function: tree_search (k, node)
  if node is a leaf then
    return node;
  switch k do
  case k ≤ k_0
    return tree_search(k, p_0);
  case k_i < k ≤ k_{i+1}
    return tree_search(k, p_{i+1});
  case k_d < k
    return tree_search(k, p_{d});
```



小王：

我有一个疑问，查询元素12时候，明明中间元素 已经存在，为什么还要继续查询走到叶子节点才算结束，

这不是浪费时间吗？



老王：

观察很仔细呀，漫画算法：什么是 B+ 树。

程序员小灰已经给出解释了，你不是看过一次，怎么忘记了！



![](https://upload-images.jianshu.io/upload_images/1765518-a2a767fc07d30e9c?imageMogr2/auto-orient/strip|imageView2/2/format/webp)



小王：

我确实看过，不过对里面一句话根本不明白  

![image.png](https://upload-images.jianshu.io/upload_images/1837968-e459ca97dc195b2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

有K个元素，K个指针 ，一个节点对应一个指针呀, 这个不对呀，2个元素会拆分3个指针呢？



### （老王） 先别急着问为什么，我演示一下插入操作





在叶子节点 (1 2 3) 上插入新元素 4 ，B  tree 结果是：

![image.png](https://upload-images.jianshu.io/upload_images/1837968-3b500db71777b853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/1837968-3d2f75f9d9ef343b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



在叶子节点 (1 2 3) 上插入新元素 4 ，B+  tree 结果是：

![image.png](https://upload-images.jianshu.io/upload_images/1837968-3b500db71777b853.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

<img src="https://upload-images.jianshu.io/upload_images/1837968-53cf890e30b9e9d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png" style="zoom:80%;" />



顺序插入元素： 1 2  3 4 5 6 7 9 10 11 创建 4 阶 B+ tree 完整演示





![B+_insert_01.gif](https://upload-images.jianshu.io/upload_images/1837968-a3839200c78e5e51.gif?imageMogr2/auto-orient/strip)



### （小王）我知道如何插入了



插入关键字k的步骤

1. 选择到叶子节点，然后插入对应位置
2. 对叶子节点做平衡检查，如果超过上界，选择中间元素+1位置这个key进行拆分到paernt节点上去。
3. 继续对父节点做做平衡检查。如果超过上界，选择中间元素+1位置这个key进行拆分到paernt节点上去
4. 重复步骤 3 

![image.png](https://upload-images.jianshu.io/upload_images/1837968-7430a044736cc19e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





（老王）请看下面删除演示















### 最后，小王偷偷写下这么几句话



   B+ tree 是一个  M 阶平衡树

1. 为了维持平衡，每个非叶子节点中子树个数上下界： M/2<=x <<M。也就是说 每个结点最多有m-1个关键字
2. 每次对叶子节点 中key的 插入，删除等操作会引起关键字超过上下界，因此需要继续进行拆分或者合并操作。
3.  因为全部信息都存储到叶子节点，这就为什么每次查询，插入，删除等操从找到叶子节点开始。



哈哈哈 



你一已经猜到 一个4阶B+tree，一个节点最多允许 3个key，4个子树指针。



因为B+ tree 结构是递归的，我只专心看最小子问题，就是一个节点组成

![](https://images2018.cnblogs.com/blog/834468/201804/834468-20180406232854940-1019144331.png)



### FQA

- 一个M阶的B+tree，M是什么意思，是节点个数，还是指针个数？目前我定义来看是孩子的最大个数?
- 每个节点 n个key和m个指针 ，n和m一定相等吗？不一定







### 参考

[B+ treeFrom Wikipedia](https://en.wikipedia.org/wiki/B%2B_tree
)

[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

[漫画算法：什么是 B+ 树](https://www.jianshu.com/p/1f2560f0e87f)

https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html