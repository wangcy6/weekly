

这就是你价值，用不一向的角度回答老问题。

> 别人回答了，那是入门时候，随笔写博客时候，应付项目时候。
>
> 别人迭代了，别人不会重写一本书，一个项目，一个博客纠正。
>
> 不会对 你对你认知负责，你需要对你理解负责





## 一、问题













## 二、你的思考（10秒闪过）





拦路虎1：大脑一片空白 不知道如何下手。浮现了五种网络IO模型 

![image.png](../images/4lPTmeKIc7syv1r.png)

有出现了 C10k问题设计, 从一个线程一个链接，发展到Reactor/Proctor 多线程涉及

最后想到应用。为了处理阻塞事件，redis nodes， st 分离出不同队列处理

menarche 通过 分离 多个Reactor，Netty（多） 与 [libevent](https://github.com/libevent/libevent)(单)

但是一片空白 不知道如何下手 的，思考2个小时，还是毫无头绪



画外音：

>  你给自己一个假设，服务器是单线程，只有read send这个2个操作，这最基本模型，这个通过了，才能考虑其他的





拦路虎2：大脑一片空白。大文件怎么做到的，需要考虑什么问题。

- 一个视频文件传输，和普通http，tcp 请求有什么区别
- 一般的通http，tcp 请求服务是怎么涉及的
- 一般的通http，tcp 请求怎么请求的
- 大文件传输是怎么涉及
- epoll(nginx,redis,tomcat)是如何处理的，做了什么措施
- https://www.zhihu.com/question/22840801



画外音：

>  你给自己一个假设，一个大文件1 G传输，一次非最塞还好阻塞 send ,还是read 是根本无法读取、



拦路虎3 想到各种技巧，异步，断线续传。



解决办法：

你会想一下你看到，你写的代码怎么样的，就是很简单 c++代码，我看到都是很简单。

无论在复杂的失去，c++总是很简单方式实现，这高效地方，只要c语言写的，就是高效。

1. for epoll_wait
2.  非阻塞，然后eagin return



- 我自己的代码

  ~~~c++
  #define MAXREADBUF 1400
  class dns_down_connect
  {
  public:
  	char	      m_ReadBuf[MAXREADBUF];
  	char          m_revBuf[READBUFLENG];
      int           m_ReadNum;
      int			  m_revBufWriterPtr;
  
  };
  
  void * connect_thread_fun(void * arg)
  {
  
  	while (1)
  		memset(pthis->m_ReadBuf, 0, MAXREADBUF);
  		nb_read = st_read_fully(pthis->m_stfd, (void *)pthis->m_ReadBuf, pthis->m_ReadNum, SRS_CONSTS_RTMP_RECV_TIMEOUT_US);
  
  		if (nb_read != pthis->m_ReadNum) {
  
  			if (nb_read < 0)
  			{
  				if (nb_read < 0 && errno == ETIME) {
  					continue;
  				}
  			}
  			pthis->m_thread = NULL;
  			st_thread_exit(NULL); //exit 
  		}
  		pthis->OnRead(nb_read);
  		
  	}
  
  }
  
  //获取数据包的长度
  _nextDataLen = *(int32 *)(m_revBuf + _dealPtr + NISMSGTYPELENG);
  swap(&_nextDataLen, sizeof(int32)); //获取数据包的长度
  
  if (_leftdatalen >= _nextDataLen + NISMSGHEADSIZE)		//一个完整包的长度
  {
  	OnMsg(m_revBuf + _dealPtr, _nextDataLen + NISMSGHEADSIZE);
  	
  	_dealPtr += _nextDataLen + NISMSGHEADSIZE; //如果一次读取多个报文，
  	_leftdatalen = m_revBufWriterPtr - _dealPtr;
  	_nextDataLen = 0;
  	continue;
  }
  
    while ((wd = ::write(fd, httpRes.data() + con.written, left)) > 0) {
          con.written += wd;
          left -= wd;
          if (output_log)
              printf("write %d bytes left: %lu\n", wd, left);
      };
      if (left == 0) {
          //        close(fd); // 测试中使用了keepalive，因此不关闭连接。连接会在read事件中关闭
          cons.erase(fd);
          return;
      }
      if (wd < 0 && (errno == EAGAIN || errno == EWOULDBLOCK))
          printf("write errno == EAGAIN || errno == EWOULDBLOCK \n");
          return;
  ~~~

  



虽然你无法用语言描述出来 

你很确定，并且肯定你答案在什么地方。



> 你假设单线程
>
> 只处理读取和发送任务，
>
> 如何读取的的。
>
> A 每个链接系统内核都默认缓冲区
>
> B 每个链接 应用也有接受 和发送缓冲区。
>
> 当A慢时候，B记录具体情况。
>
> all 代码都是这样写的，我从来接见过不这样写的。



虽然你无法用语言描述出来 

你很确定，并且肯定你答案在什么地方。



画外音

>  你考虑的各种网络模型 还有多线程模式 lib Event 还有Netty框架帮助完成了，但是居然每次读写怎么用靠自己。你体验框架怎么用

## 三、你的回答（限制在1分钟，5句话，12秒一句）











## 四、鸡蛋里挑骨头（第一句话回答关键了吗，后面有具体场景吗？或者关键词补充吗）

> 里面有3点，你回答一点，还是完全通过book 还有老师 ，领导告诉你点，你思考在那里





## 五、你自己满意了吗,认为过关了

1. 10秒内单，如果大脑一片空白，对里面里面基础用法（不行）

2. 进一步 提问，原理，异常等毫无总结，（不行）

3. 你必须停下来深入看看看别人怎么做的（学习吧）





## 六、下一个问题是什么（这不是结束，只是一个系统的开始）



## 七、如果自己没有做过类型项目，参考别人经验，自己重新设计，需要考虑知识点是什么？

https://www.zhihu.com/question/49947156

https://github.com/zeromq/libzmq/blob/master/src/epoll.cpp#L148

### 八、如果自己没有做过类型项目，自己直接写demo，最容易忽视地方是什么？







# 如何像nginx一样高效的发送大文件

https://zhuanlan.zhihu.com/p/21619218

https://www.zhihu.com/question/22840801

 先了解epoll编程，项目中raw_example下面有例子
. 先阅读readme，还有文档
. 按照例子编写几个程序，试试
. poller对epoll进行了简单的封装，出来一个可移植的接口
. event_base是整个框架
. conn是tcp的连接与服务器